/* protocolv2C.cpp
   Generated by gSOAP 2.8.111 for cwebservice.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "protocolv2H.h"

namespace protocolv2 {

SOAP_SOURCE_STAMP("@(#) protocolv2C.cpp ver 2.8.111 2021-03-18 08:34:29 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
	}
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code == NULL)
		soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason == NULL)
		soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
				return NULL;
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_subcode(struct soap *soap)
{
	const char **s = soap_faultsubcode(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_string(struct soap *soap)
{
	const char **s = soap_faultstring(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
			soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
		soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_detail(struct soap *soap)
{
	const char **s = soap_faultdetail(soap);
	return s ? *s : NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, NULL, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, const char *tag, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_protocolv2_byte:
		return soap_in_byte(soap, tag, NULL, "xsd:byte");
	case SOAP_TYPE_protocolv2_int:
		return soap_in_int(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_protocolv2_dateTime:
		return soap_in_dateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_protocolv2_ns1__ArrayOfCCompteurArticle:
		return soap_in_ns1__ArrayOfCCompteurArticle(soap, tag, NULL, "ns1:ArrayOfCCompteurArticle");
	case SOAP_TYPE_protocolv2_ns1__CCompteurArticle:
		return soap_in_ns1__CCompteurArticle(soap, tag, NULL, "ns1:CCompteurArticle");
	case SOAP_TYPE_protocolv2_ns1__CCounter:
		return soap_in_ns1__CCounter(soap, tag, NULL, "ns1:CCounter");
	case SOAP_TYPE_protocolv2_ns1__CCompteurMouleCapteur:
		return soap_in_ns1__CCompteurMouleCapteur(soap, tag, NULL, "ns1:CCompteurMouleCapteur");
	case SOAP_TYPE_protocolv2_ns1__CCompteurMoule:
		return soap_in_ns1__CCompteurMoule(soap, tag, NULL, "ns1:CCompteurMoule");
	case SOAP_TYPE_protocolv2_ns1__CCompteurMachine:
		return soap_in_ns1__CCompteurMachine(soap, tag, NULL, "ns1:CCompteurMachine");
	case SOAP_TYPE_protocolv2_ns1__CountsByArticleResult:
		return soap_in_ns1__CountsByArticleResult(soap, tag, NULL, "ns1:CountsByArticleResult");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__GetLastRequestDate:
		return soap_in_PointerTo_ns1__GetLastRequestDate(soap, tag, NULL, "ns1:GetLastRequestDate");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__AddSamples:
		return soap_in_PointerTo_ns1__AddSamples(soap, tag, NULL, "ns1:AddSamples");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__AddEjectedMolds:
		return soap_in_PointerTo_ns1__AddEjectedMolds(soap, tag, NULL, "ns1:AddEjectedMolds");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__AddMountedMolds:
		return soap_in_PointerTo_ns1__AddMountedMolds(soap, tag, NULL, "ns1:AddMountedMolds");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__Samples:
		return soap_in_PointerTo_ns1__Samples(soap, tag, NULL, "ns1:Samples");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__Alarms:
		return soap_in_PointerTo_ns1__Alarms(soap, tag, NULL, "ns1:Alarms");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__Measures:
		return soap_in_PointerTo_ns1__Measures(soap, tag, NULL, "ns1:Measures");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__ReadenMolds:
		return soap_in_PointerTo_ns1__ReadenMolds(soap, tag, NULL, "ns1:ReadenMolds");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__EjectedMolds:
		return soap_in_PointerTo_ns1__EjectedMolds(soap, tag, NULL, "ns1:EjectedMolds");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__MountedMolds:
		return soap_in_PointerTo_ns1__MountedMolds(soap, tag, NULL, "ns1:MountedMolds");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__GetUpdatedLastRequestDate:
		return soap_in_PointerTo_ns1__GetUpdatedLastRequestDate(soap, tag, NULL, "ns1:GetUpdatedLastRequestDate");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__PreserveCounts:
		return soap_in_PointerTo_ns1__PreserveCounts(soap, tag, NULL, "ns1:PreserveCounts");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__CountsByArticle:
		return soap_in_PointerTo_ns1__CountsByArticle(soap, tag, NULL, "ns1:CountsByArticle");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__Counts:
		return soap_in_PointerTo_ns1__Counts(soap, tag, NULL, "ns1:Counts");
	case SOAP_TYPE_protocolv2_PointerToPointerTons1__CCompteurMouleCapteur:
		return soap_in_PointerToPointerTons1__CCompteurMouleCapteur(soap, tag, NULL, "ns1:CCompteurMouleCapteur");
	case SOAP_TYPE_protocolv2_PointerTons1__CCompteurMouleCapteur:
		return soap_in_PointerTons1__CCompteurMouleCapteur(soap, tag, NULL, "ns1:CCompteurMouleCapteur");
	case SOAP_TYPE_protocolv2_PointerToPointerTons1__CCounter:
		return soap_in_PointerToPointerTons1__CCounter(soap, tag, NULL, "ns1:CCounter");
	case SOAP_TYPE_protocolv2_PointerTons1__CCounter:
		return soap_in_PointerTons1__CCounter(soap, tag, NULL, "ns1:CCounter");
	case SOAP_TYPE_protocolv2_PointerTons1__ArrayOfCCompteurArticle:
		return soap_in_PointerTons1__ArrayOfCCompteurArticle(soap, tag, NULL, "ns1:ArrayOfCCompteurArticle");
	case SOAP_TYPE_protocolv2_PointerTons1__CountsByArticleResult:
		return soap_in_PointerTons1__CountsByArticleResult(soap, tag, NULL, "ns1:CountsByArticleResult");
	case SOAP_TYPE_protocolv2_PointerToPointerTons1__CCompteurArticle:
		return soap_in_PointerToPointerTons1__CCompteurArticle(soap, tag, NULL, "ns1:CCompteurArticle");
	case SOAP_TYPE_protocolv2_PointerTons1__CCompteurArticle:
		return soap_in_PointerTons1__CCompteurArticle(soap, tag, NULL, "ns1:CCompteurArticle");
	case SOAP_TYPE_protocolv2_PointerToint:
		return soap_in_PointerToint(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_protocolv2_PointerTons1__CCompteurMachine:
		return soap_in_PointerTons1__CCompteurMachine(soap, tag, NULL, "ns1:CCompteurMachine");
	case SOAP_TYPE_protocolv2__QName:
	{	char **s;
		s = soap_in__QName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_protocolv2_string:
	{	char **s;
		s = soap_in_string(soap, tag, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:ArrayOfCCompteurArticle"))
		{	*type = SOAP_TYPE_protocolv2_ns1__ArrayOfCCompteurArticle;
			return soap_in_ns1__ArrayOfCCompteurArticle(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CCompteurArticle"))
		{	*type = SOAP_TYPE_protocolv2_ns1__CCompteurArticle;
			return soap_in_ns1__CCompteurArticle(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CCounter"))
		{	*type = SOAP_TYPE_protocolv2_ns1__CCounter;
			return soap_in_ns1__CCounter(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CCompteurMouleCapteur"))
		{	*type = SOAP_TYPE_protocolv2_ns1__CCompteurMouleCapteur;
			return soap_in_ns1__CCompteurMouleCapteur(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CCompteurMoule"))
		{	*type = SOAP_TYPE_protocolv2_ns1__CCompteurMoule;
			return soap_in_ns1__CCompteurMoule(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CCompteurMachine"))
		{	*type = SOAP_TYPE_protocolv2_ns1__CCompteurMachine;
			return soap_in_ns1__CCompteurMachine(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CountsByArticleResult"))
		{	*type = SOAP_TYPE_protocolv2_ns1__CountsByArticleResult;
			return soap_in_ns1__CountsByArticleResult(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_protocolv2_byte;
			return soap_in_byte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_protocolv2_int;
			return soap_in_int(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_protocolv2_dateTime;
			return soap_in_dateTime(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE_protocolv2__QName;
			s = soap_in__QName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_protocolv2_string;
			s = soap_in_string(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:GetLastRequestDateResponse"))
		{	*type = SOAP_TYPE_protocolv2__ns1__GetLastRequestDateResponse;
			return soap_in__ns1__GetLastRequestDateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLastRequestDate"))
		{	*type = SOAP_TYPE_protocolv2__ns1__GetLastRequestDate;
			return soap_in__ns1__GetLastRequestDate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddSamplesResponse"))
		{	*type = SOAP_TYPE_protocolv2__ns1__AddSamplesResponse;
			return soap_in__ns1__AddSamplesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddSamples"))
		{	*type = SOAP_TYPE_protocolv2__ns1__AddSamples;
			return soap_in__ns1__AddSamples(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddEjectedMoldsResponse"))
		{	*type = SOAP_TYPE_protocolv2__ns1__AddEjectedMoldsResponse;
			return soap_in__ns1__AddEjectedMoldsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddEjectedMolds"))
		{	*type = SOAP_TYPE_protocolv2__ns1__AddEjectedMolds;
			return soap_in__ns1__AddEjectedMolds(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddMountedMoldsResponse"))
		{	*type = SOAP_TYPE_protocolv2__ns1__AddMountedMoldsResponse;
			return soap_in__ns1__AddMountedMoldsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddMountedMolds"))
		{	*type = SOAP_TYPE_protocolv2__ns1__AddMountedMolds;
			return soap_in__ns1__AddMountedMolds(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SamplesResponse"))
		{	*type = SOAP_TYPE_protocolv2__ns1__SamplesResponse;
			return soap_in__ns1__SamplesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Samples"))
		{	*type = SOAP_TYPE_protocolv2__ns1__Samples;
			return soap_in__ns1__Samples(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AlarmsResponse"))
		{	*type = SOAP_TYPE_protocolv2__ns1__AlarmsResponse;
			return soap_in__ns1__AlarmsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Alarms"))
		{	*type = SOAP_TYPE_protocolv2__ns1__Alarms;
			return soap_in__ns1__Alarms(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MeasuresResponse"))
		{	*type = SOAP_TYPE_protocolv2__ns1__MeasuresResponse;
			return soap_in__ns1__MeasuresResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Measures"))
		{	*type = SOAP_TYPE_protocolv2__ns1__Measures;
			return soap_in__ns1__Measures(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ReadenMoldsResponse"))
		{	*type = SOAP_TYPE_protocolv2__ns1__ReadenMoldsResponse;
			return soap_in__ns1__ReadenMoldsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ReadenMolds"))
		{	*type = SOAP_TYPE_protocolv2__ns1__ReadenMolds;
			return soap_in__ns1__ReadenMolds(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EjectedMoldsResponse"))
		{	*type = SOAP_TYPE_protocolv2__ns1__EjectedMoldsResponse;
			return soap_in__ns1__EjectedMoldsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EjectedMolds"))
		{	*type = SOAP_TYPE_protocolv2__ns1__EjectedMolds;
			return soap_in__ns1__EjectedMolds(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MountedMoldsResponse"))
		{	*type = SOAP_TYPE_protocolv2__ns1__MountedMoldsResponse;
			return soap_in__ns1__MountedMoldsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MountedMolds"))
		{	*type = SOAP_TYPE_protocolv2__ns1__MountedMolds;
			return soap_in__ns1__MountedMolds(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetUpdatedLastRequestDateResponse"))
		{	*type = SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDateResponse;
			return soap_in__ns1__GetUpdatedLastRequestDateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetUpdatedLastRequestDate"))
		{	*type = SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDate;
			return soap_in__ns1__GetUpdatedLastRequestDate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PreserveCountsResponse"))
		{	*type = SOAP_TYPE_protocolv2__ns1__PreserveCountsResponse;
			return soap_in__ns1__PreserveCountsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PreserveCounts"))
		{	*type = SOAP_TYPE_protocolv2__ns1__PreserveCounts;
			return soap_in__ns1__PreserveCounts(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CountsByArticleResponse"))
		{	*type = SOAP_TYPE_protocolv2__ns1__CountsByArticleResponse;
			return soap_in__ns1__CountsByArticleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CountsByArticle"))
		{	*type = SOAP_TYPE_protocolv2__ns1__CountsByArticle;
			return soap_in__ns1__CountsByArticle(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CountsResponse"))
		{	*type = SOAP_TYPE_protocolv2__ns1__CountsResponse;
			return soap_in__ns1__CountsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Counts"))
		{	*type = SOAP_TYPE_protocolv2__ns1__Counts;
			return soap_in__ns1__Counts(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input at level = %u body = %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, NULL, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_protocolv2_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_protocolv2_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_protocolv2_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_protocolv2__ns1__GetLastRequestDateResponse:
		return ((_ns1__GetLastRequestDateResponse *)ptr)->soap_out(soap, "ns1:GetLastRequestDateResponse", id, "");
	case SOAP_TYPE_protocolv2__ns1__GetLastRequestDate:
		return ((_ns1__GetLastRequestDate *)ptr)->soap_out(soap, "ns1:GetLastRequestDate", id, "");
	case SOAP_TYPE_protocolv2__ns1__AddSamplesResponse:
		return ((_ns1__AddSamplesResponse *)ptr)->soap_out(soap, "ns1:AddSamplesResponse", id, "");
	case SOAP_TYPE_protocolv2__ns1__AddSamples:
		return ((_ns1__AddSamples *)ptr)->soap_out(soap, "ns1:AddSamples", id, "");
	case SOAP_TYPE_protocolv2__ns1__AddEjectedMoldsResponse:
		return ((_ns1__AddEjectedMoldsResponse *)ptr)->soap_out(soap, "ns1:AddEjectedMoldsResponse", id, "");
	case SOAP_TYPE_protocolv2__ns1__AddEjectedMolds:
		return ((_ns1__AddEjectedMolds *)ptr)->soap_out(soap, "ns1:AddEjectedMolds", id, "");
	case SOAP_TYPE_protocolv2__ns1__AddMountedMoldsResponse:
		return ((_ns1__AddMountedMoldsResponse *)ptr)->soap_out(soap, "ns1:AddMountedMoldsResponse", id, "");
	case SOAP_TYPE_protocolv2__ns1__AddMountedMolds:
		return ((_ns1__AddMountedMolds *)ptr)->soap_out(soap, "ns1:AddMountedMolds", id, "");
	case SOAP_TYPE_protocolv2__ns1__SamplesResponse:
		return ((_ns1__SamplesResponse *)ptr)->soap_out(soap, "ns1:SamplesResponse", id, "");
	case SOAP_TYPE_protocolv2__ns1__Samples:
		return ((_ns1__Samples *)ptr)->soap_out(soap, "ns1:Samples", id, "");
	case SOAP_TYPE_protocolv2__ns1__AlarmsResponse:
		return ((_ns1__AlarmsResponse *)ptr)->soap_out(soap, "ns1:AlarmsResponse", id, "");
	case SOAP_TYPE_protocolv2__ns1__Alarms:
		return ((_ns1__Alarms *)ptr)->soap_out(soap, "ns1:Alarms", id, "");
	case SOAP_TYPE_protocolv2__ns1__MeasuresResponse:
		return ((_ns1__MeasuresResponse *)ptr)->soap_out(soap, "ns1:MeasuresResponse", id, "");
	case SOAP_TYPE_protocolv2__ns1__Measures:
		return ((_ns1__Measures *)ptr)->soap_out(soap, "ns1:Measures", id, "");
	case SOAP_TYPE_protocolv2__ns1__ReadenMoldsResponse:
		return ((_ns1__ReadenMoldsResponse *)ptr)->soap_out(soap, "ns1:ReadenMoldsResponse", id, "");
	case SOAP_TYPE_protocolv2__ns1__ReadenMolds:
		return ((_ns1__ReadenMolds *)ptr)->soap_out(soap, "ns1:ReadenMolds", id, "");
	case SOAP_TYPE_protocolv2__ns1__EjectedMoldsResponse:
		return ((_ns1__EjectedMoldsResponse *)ptr)->soap_out(soap, "ns1:EjectedMoldsResponse", id, "");
	case SOAP_TYPE_protocolv2__ns1__EjectedMolds:
		return ((_ns1__EjectedMolds *)ptr)->soap_out(soap, "ns1:EjectedMolds", id, "");
	case SOAP_TYPE_protocolv2__ns1__MountedMoldsResponse:
		return ((_ns1__MountedMoldsResponse *)ptr)->soap_out(soap, "ns1:MountedMoldsResponse", id, "");
	case SOAP_TYPE_protocolv2__ns1__MountedMolds:
		return ((_ns1__MountedMolds *)ptr)->soap_out(soap, "ns1:MountedMolds", id, "");
	case SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDateResponse:
		return ((_ns1__GetUpdatedLastRequestDateResponse *)ptr)->soap_out(soap, "ns1:GetUpdatedLastRequestDateResponse", id, "");
	case SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDate:
		return ((_ns1__GetUpdatedLastRequestDate *)ptr)->soap_out(soap, "ns1:GetUpdatedLastRequestDate", id, "");
	case SOAP_TYPE_protocolv2__ns1__PreserveCountsResponse:
		return ((_ns1__PreserveCountsResponse *)ptr)->soap_out(soap, "ns1:PreserveCountsResponse", id, "");
	case SOAP_TYPE_protocolv2__ns1__PreserveCounts:
		return ((_ns1__PreserveCounts *)ptr)->soap_out(soap, "ns1:PreserveCounts", id, "");
	case SOAP_TYPE_protocolv2__ns1__CountsByArticleResponse:
		return ((_ns1__CountsByArticleResponse *)ptr)->soap_out(soap, "ns1:CountsByArticleResponse", id, "");
	case SOAP_TYPE_protocolv2__ns1__CountsByArticle:
		return ((_ns1__CountsByArticle *)ptr)->soap_out(soap, "ns1:CountsByArticle", id, "");
	case SOAP_TYPE_protocolv2__ns1__CountsResponse:
		return ((_ns1__CountsResponse *)ptr)->soap_out(soap, "ns1:CountsResponse", id, "");
	case SOAP_TYPE_protocolv2__ns1__Counts:
		return ((_ns1__Counts *)ptr)->soap_out(soap, "ns1:Counts", id, "");
	case SOAP_TYPE_protocolv2_ns1__ArrayOfCCompteurArticle:
		return ((ns1__ArrayOfCCompteurArticle *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfCCompteurArticle");
	case SOAP_TYPE_protocolv2_ns1__CCompteurArticle:
		return ((ns1__CCompteurArticle *)ptr)->soap_out(soap, tag, id, "ns1:CCompteurArticle");
	case SOAP_TYPE_protocolv2_ns1__CCounter:
		return ((ns1__CCounter *)ptr)->soap_out(soap, tag, id, "ns1:CCounter");
	case SOAP_TYPE_protocolv2_ns1__CCompteurMouleCapteur:
		return ((ns1__CCompteurMouleCapteur *)ptr)->soap_out(soap, tag, id, "ns1:CCompteurMouleCapteur");
	case SOAP_TYPE_protocolv2_ns1__CCompteurMoule:
		return ((ns1__CCompteurMoule *)ptr)->soap_out(soap, tag, id, "ns1:CCompteurMoule");
	case SOAP_TYPE_protocolv2_ns1__CCompteurMachine:
		return ((ns1__CCompteurMachine *)ptr)->soap_out(soap, tag, id, "ns1:CCompteurMachine");
	case SOAP_TYPE_protocolv2_ns1__CountsByArticleResult:
		return ((ns1__CountsByArticleResult *)ptr)->soap_out(soap, tag, id, "ns1:CountsByArticleResult");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__GetLastRequestDate:
		return soap_out_PointerTo_ns1__GetLastRequestDate(soap, tag, id, (_ns1__GetLastRequestDate *const*)ptr, "ns1:GetLastRequestDate");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__AddSamples:
		return soap_out_PointerTo_ns1__AddSamples(soap, tag, id, (_ns1__AddSamples *const*)ptr, "ns1:AddSamples");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__AddEjectedMolds:
		return soap_out_PointerTo_ns1__AddEjectedMolds(soap, tag, id, (_ns1__AddEjectedMolds *const*)ptr, "ns1:AddEjectedMolds");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__AddMountedMolds:
		return soap_out_PointerTo_ns1__AddMountedMolds(soap, tag, id, (_ns1__AddMountedMolds *const*)ptr, "ns1:AddMountedMolds");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__Samples:
		return soap_out_PointerTo_ns1__Samples(soap, tag, id, (_ns1__Samples *const*)ptr, "ns1:Samples");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__Alarms:
		return soap_out_PointerTo_ns1__Alarms(soap, tag, id, (_ns1__Alarms *const*)ptr, "ns1:Alarms");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__Measures:
		return soap_out_PointerTo_ns1__Measures(soap, tag, id, (_ns1__Measures *const*)ptr, "ns1:Measures");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__ReadenMolds:
		return soap_out_PointerTo_ns1__ReadenMolds(soap, tag, id, (_ns1__ReadenMolds *const*)ptr, "ns1:ReadenMolds");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__EjectedMolds:
		return soap_out_PointerTo_ns1__EjectedMolds(soap, tag, id, (_ns1__EjectedMolds *const*)ptr, "ns1:EjectedMolds");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__MountedMolds:
		return soap_out_PointerTo_ns1__MountedMolds(soap, tag, id, (_ns1__MountedMolds *const*)ptr, "ns1:MountedMolds");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__GetUpdatedLastRequestDate:
		return soap_out_PointerTo_ns1__GetUpdatedLastRequestDate(soap, tag, id, (_ns1__GetUpdatedLastRequestDate *const*)ptr, "ns1:GetUpdatedLastRequestDate");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__PreserveCounts:
		return soap_out_PointerTo_ns1__PreserveCounts(soap, tag, id, (_ns1__PreserveCounts *const*)ptr, "ns1:PreserveCounts");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__CountsByArticle:
		return soap_out_PointerTo_ns1__CountsByArticle(soap, tag, id, (_ns1__CountsByArticle *const*)ptr, "ns1:CountsByArticle");
	case SOAP_TYPE_protocolv2_PointerTo_ns1__Counts:
		return soap_out_PointerTo_ns1__Counts(soap, tag, id, (_ns1__Counts *const*)ptr, "ns1:Counts");
	case SOAP_TYPE_protocolv2_PointerToPointerTons1__CCompteurMouleCapteur:
		return soap_out_PointerToPointerTons1__CCompteurMouleCapteur(soap, tag, id, (ns1__CCompteurMouleCapteur **const*)ptr, "ns1:CCompteurMouleCapteur");
	case SOAP_TYPE_protocolv2_PointerTons1__CCompteurMouleCapteur:
		return soap_out_PointerTons1__CCompteurMouleCapteur(soap, tag, id, (ns1__CCompteurMouleCapteur *const*)ptr, "ns1:CCompteurMouleCapteur");
	case SOAP_TYPE_protocolv2_PointerToPointerTons1__CCounter:
		return soap_out_PointerToPointerTons1__CCounter(soap, tag, id, (ns1__CCounter **const*)ptr, "ns1:CCounter");
	case SOAP_TYPE_protocolv2_PointerTons1__CCounter:
		return soap_out_PointerTons1__CCounter(soap, tag, id, (ns1__CCounter *const*)ptr, "ns1:CCounter");
	case SOAP_TYPE_protocolv2_PointerTons1__ArrayOfCCompteurArticle:
		return soap_out_PointerTons1__ArrayOfCCompteurArticle(soap, tag, id, (ns1__ArrayOfCCompteurArticle *const*)ptr, "ns1:ArrayOfCCompteurArticle");
	case SOAP_TYPE_protocolv2_PointerTons1__CountsByArticleResult:
		return soap_out_PointerTons1__CountsByArticleResult(soap, tag, id, (ns1__CountsByArticleResult *const*)ptr, "ns1:CountsByArticleResult");
	case SOAP_TYPE_protocolv2_PointerToPointerTons1__CCompteurArticle:
		return soap_out_PointerToPointerTons1__CCompteurArticle(soap, tag, id, (ns1__CCompteurArticle **const*)ptr, "ns1:CCompteurArticle");
	case SOAP_TYPE_protocolv2_PointerTons1__CCompteurArticle:
		return soap_out_PointerTons1__CCompteurArticle(soap, tag, id, (ns1__CCompteurArticle *const*)ptr, "ns1:CCompteurArticle");
	case SOAP_TYPE_protocolv2_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_protocolv2_PointerTons1__CCompteurMachine:
		return soap_out_PointerTons1__CCompteurMachine(soap, tag, id, (ns1__CCompteurMachine *const*)ptr, "ns1:CCompteurMachine");
	case SOAP_TYPE_protocolv2__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_protocolv2_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in ./src\\protocolv2C.cpp\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag, 0, NULL); /* unknown type to serialize */
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_protocolv2__ns1__GetLastRequestDateResponse:
		((_ns1__GetLastRequestDateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2__ns1__GetLastRequestDate:
		((_ns1__GetLastRequestDate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2__ns1__AddSamplesResponse:
		((_ns1__AddSamplesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2__ns1__AddSamples:
		((_ns1__AddSamples *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2__ns1__AddEjectedMoldsResponse:
		((_ns1__AddEjectedMoldsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2__ns1__AddEjectedMolds:
		((_ns1__AddEjectedMolds *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2__ns1__AddMountedMoldsResponse:
		((_ns1__AddMountedMoldsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2__ns1__AddMountedMolds:
		((_ns1__AddMountedMolds *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2__ns1__SamplesResponse:
		((_ns1__SamplesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2__ns1__Samples:
		((_ns1__Samples *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2__ns1__AlarmsResponse:
		((_ns1__AlarmsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2__ns1__Alarms:
		((_ns1__Alarms *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2__ns1__MeasuresResponse:
		((_ns1__MeasuresResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2__ns1__Measures:
		((_ns1__Measures *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2__ns1__ReadenMoldsResponse:
		((_ns1__ReadenMoldsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2__ns1__ReadenMolds:
		((_ns1__ReadenMolds *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2__ns1__EjectedMoldsResponse:
		((_ns1__EjectedMoldsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2__ns1__EjectedMolds:
		((_ns1__EjectedMolds *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2__ns1__MountedMoldsResponse:
		((_ns1__MountedMoldsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2__ns1__MountedMolds:
		((_ns1__MountedMolds *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDateResponse:
		((_ns1__GetUpdatedLastRequestDateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDate:
		((_ns1__GetUpdatedLastRequestDate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2__ns1__PreserveCountsResponse:
		((_ns1__PreserveCountsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2__ns1__PreserveCounts:
		((_ns1__PreserveCounts *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2__ns1__CountsByArticleResponse:
		((_ns1__CountsByArticleResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2__ns1__CountsByArticle:
		((_ns1__CountsByArticle *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2__ns1__CountsResponse:
		((_ns1__CountsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2__ns1__Counts:
		((_ns1__Counts *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2_ns1__ArrayOfCCompteurArticle:
		((ns1__ArrayOfCCompteurArticle *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2_ns1__CCompteurArticle:
		((ns1__CCompteurArticle *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2_ns1__CCounter:
		((ns1__CCounter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2_ns1__CCompteurMouleCapteur:
		((ns1__CCompteurMouleCapteur *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2_ns1__CCompteurMoule:
		((ns1__CCompteurMoule *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2_ns1__CCompteurMachine:
		((ns1__CCompteurMachine *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2_ns1__CountsByArticleResult:
		((ns1__CountsByArticleResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_protocolv2___ns1__GetLastRequestDate_:
		soap_serialize___ns1__GetLastRequestDate_(soap, (const struct __ns1__GetLastRequestDate_ *)ptr);
		break;
	case SOAP_TYPE_protocolv2___ns1__AddSamples_:
		soap_serialize___ns1__AddSamples_(soap, (const struct __ns1__AddSamples_ *)ptr);
		break;
	case SOAP_TYPE_protocolv2___ns1__AddEjectedMolds_:
		soap_serialize___ns1__AddEjectedMolds_(soap, (const struct __ns1__AddEjectedMolds_ *)ptr);
		break;
	case SOAP_TYPE_protocolv2___ns1__AddMountedMolds_:
		soap_serialize___ns1__AddMountedMolds_(soap, (const struct __ns1__AddMountedMolds_ *)ptr);
		break;
	case SOAP_TYPE_protocolv2___ns1__Samples_:
		soap_serialize___ns1__Samples_(soap, (const struct __ns1__Samples_ *)ptr);
		break;
	case SOAP_TYPE_protocolv2___ns1__Alarms_:
		soap_serialize___ns1__Alarms_(soap, (const struct __ns1__Alarms_ *)ptr);
		break;
	case SOAP_TYPE_protocolv2___ns1__Measures_:
		soap_serialize___ns1__Measures_(soap, (const struct __ns1__Measures_ *)ptr);
		break;
	case SOAP_TYPE_protocolv2___ns1__ReadenMolds_:
		soap_serialize___ns1__ReadenMolds_(soap, (const struct __ns1__ReadenMolds_ *)ptr);
		break;
	case SOAP_TYPE_protocolv2___ns1__EjectedMolds_:
		soap_serialize___ns1__EjectedMolds_(soap, (const struct __ns1__EjectedMolds_ *)ptr);
		break;
	case SOAP_TYPE_protocolv2___ns1__MountedMolds_:
		soap_serialize___ns1__MountedMolds_(soap, (const struct __ns1__MountedMolds_ *)ptr);
		break;
	case SOAP_TYPE_protocolv2___ns1__GetUpdatedLastRequestDate_:
		soap_serialize___ns1__GetUpdatedLastRequestDate_(soap, (const struct __ns1__GetUpdatedLastRequestDate_ *)ptr);
		break;
	case SOAP_TYPE_protocolv2___ns1__PreserveCounts_:
		soap_serialize___ns1__PreserveCounts_(soap, (const struct __ns1__PreserveCounts_ *)ptr);
		break;
	case SOAP_TYPE_protocolv2___ns1__CountsByArticle_:
		soap_serialize___ns1__CountsByArticle_(soap, (const struct __ns1__CountsByArticle_ *)ptr);
		break;
	case SOAP_TYPE_protocolv2___ns1__Counts_:
		soap_serialize___ns1__Counts_(soap, (const struct __ns1__Counts_ *)ptr);
		break;
	case SOAP_TYPE_protocolv2___ns1__GetLastRequestDate:
		soap_serialize___ns1__GetLastRequestDate(soap, (const struct __ns1__GetLastRequestDate *)ptr);
		break;
	case SOAP_TYPE_protocolv2___ns1__AddSamples:
		soap_serialize___ns1__AddSamples(soap, (const struct __ns1__AddSamples *)ptr);
		break;
	case SOAP_TYPE_protocolv2___ns1__AddEjectedMolds:
		soap_serialize___ns1__AddEjectedMolds(soap, (const struct __ns1__AddEjectedMolds *)ptr);
		break;
	case SOAP_TYPE_protocolv2___ns1__AddMountedMolds:
		soap_serialize___ns1__AddMountedMolds(soap, (const struct __ns1__AddMountedMolds *)ptr);
		break;
	case SOAP_TYPE_protocolv2___ns1__Samples:
		soap_serialize___ns1__Samples(soap, (const struct __ns1__Samples *)ptr);
		break;
	case SOAP_TYPE_protocolv2___ns1__Alarms:
		soap_serialize___ns1__Alarms(soap, (const struct __ns1__Alarms *)ptr);
		break;
	case SOAP_TYPE_protocolv2___ns1__Measures:
		soap_serialize___ns1__Measures(soap, (const struct __ns1__Measures *)ptr);
		break;
	case SOAP_TYPE_protocolv2___ns1__ReadenMolds:
		soap_serialize___ns1__ReadenMolds(soap, (const struct __ns1__ReadenMolds *)ptr);
		break;
	case SOAP_TYPE_protocolv2___ns1__EjectedMolds:
		soap_serialize___ns1__EjectedMolds(soap, (const struct __ns1__EjectedMolds *)ptr);
		break;
	case SOAP_TYPE_protocolv2___ns1__MountedMolds:
		soap_serialize___ns1__MountedMolds(soap, (const struct __ns1__MountedMolds *)ptr);
		break;
	case SOAP_TYPE_protocolv2___ns1__GetUpdatedLastRequestDate:
		soap_serialize___ns1__GetUpdatedLastRequestDate(soap, (const struct __ns1__GetUpdatedLastRequestDate *)ptr);
		break;
	case SOAP_TYPE_protocolv2___ns1__PreserveCounts:
		soap_serialize___ns1__PreserveCounts(soap, (const struct __ns1__PreserveCounts *)ptr);
		break;
	case SOAP_TYPE_protocolv2___ns1__CountsByArticle:
		soap_serialize___ns1__CountsByArticle(soap, (const struct __ns1__CountsByArticle *)ptr);
		break;
	case SOAP_TYPE_protocolv2___ns1__Counts:
		soap_serialize___ns1__Counts(soap, (const struct __ns1__Counts *)ptr);
		break;
	case SOAP_TYPE_protocolv2_PointerTo_ns1__GetLastRequestDate:
		soap_serialize_PointerTo_ns1__GetLastRequestDate(soap, (_ns1__GetLastRequestDate *const*)ptr);
		break;
	case SOAP_TYPE_protocolv2_PointerTo_ns1__AddSamples:
		soap_serialize_PointerTo_ns1__AddSamples(soap, (_ns1__AddSamples *const*)ptr);
		break;
	case SOAP_TYPE_protocolv2_PointerTo_ns1__AddEjectedMolds:
		soap_serialize_PointerTo_ns1__AddEjectedMolds(soap, (_ns1__AddEjectedMolds *const*)ptr);
		break;
	case SOAP_TYPE_protocolv2_PointerTo_ns1__AddMountedMolds:
		soap_serialize_PointerTo_ns1__AddMountedMolds(soap, (_ns1__AddMountedMolds *const*)ptr);
		break;
	case SOAP_TYPE_protocolv2_PointerTo_ns1__Samples:
		soap_serialize_PointerTo_ns1__Samples(soap, (_ns1__Samples *const*)ptr);
		break;
	case SOAP_TYPE_protocolv2_PointerTo_ns1__Alarms:
		soap_serialize_PointerTo_ns1__Alarms(soap, (_ns1__Alarms *const*)ptr);
		break;
	case SOAP_TYPE_protocolv2_PointerTo_ns1__Measures:
		soap_serialize_PointerTo_ns1__Measures(soap, (_ns1__Measures *const*)ptr);
		break;
	case SOAP_TYPE_protocolv2_PointerTo_ns1__ReadenMolds:
		soap_serialize_PointerTo_ns1__ReadenMolds(soap, (_ns1__ReadenMolds *const*)ptr);
		break;
	case SOAP_TYPE_protocolv2_PointerTo_ns1__EjectedMolds:
		soap_serialize_PointerTo_ns1__EjectedMolds(soap, (_ns1__EjectedMolds *const*)ptr);
		break;
	case SOAP_TYPE_protocolv2_PointerTo_ns1__MountedMolds:
		soap_serialize_PointerTo_ns1__MountedMolds(soap, (_ns1__MountedMolds *const*)ptr);
		break;
	case SOAP_TYPE_protocolv2_PointerTo_ns1__GetUpdatedLastRequestDate:
		soap_serialize_PointerTo_ns1__GetUpdatedLastRequestDate(soap, (_ns1__GetUpdatedLastRequestDate *const*)ptr);
		break;
	case SOAP_TYPE_protocolv2_PointerTo_ns1__PreserveCounts:
		soap_serialize_PointerTo_ns1__PreserveCounts(soap, (_ns1__PreserveCounts *const*)ptr);
		break;
	case SOAP_TYPE_protocolv2_PointerTo_ns1__CountsByArticle:
		soap_serialize_PointerTo_ns1__CountsByArticle(soap, (_ns1__CountsByArticle *const*)ptr);
		break;
	case SOAP_TYPE_protocolv2_PointerTo_ns1__Counts:
		soap_serialize_PointerTo_ns1__Counts(soap, (_ns1__Counts *const*)ptr);
		break;
	case SOAP_TYPE_protocolv2_PointerToPointerTons1__CCompteurMouleCapteur:
		soap_serialize_PointerToPointerTons1__CCompteurMouleCapteur(soap, (ns1__CCompteurMouleCapteur **const*)ptr);
		break;
	case SOAP_TYPE_protocolv2_PointerTons1__CCompteurMouleCapteur:
		soap_serialize_PointerTons1__CCompteurMouleCapteur(soap, (ns1__CCompteurMouleCapteur *const*)ptr);
		break;
	case SOAP_TYPE_protocolv2_PointerToPointerTons1__CCounter:
		soap_serialize_PointerToPointerTons1__CCounter(soap, (ns1__CCounter **const*)ptr);
		break;
	case SOAP_TYPE_protocolv2_PointerTons1__CCounter:
		soap_serialize_PointerTons1__CCounter(soap, (ns1__CCounter *const*)ptr);
		break;
	case SOAP_TYPE_protocolv2_PointerTons1__ArrayOfCCompteurArticle:
		soap_serialize_PointerTons1__ArrayOfCCompteurArticle(soap, (ns1__ArrayOfCCompteurArticle *const*)ptr);
		break;
	case SOAP_TYPE_protocolv2_PointerTons1__CountsByArticleResult:
		soap_serialize_PointerTons1__CountsByArticleResult(soap, (ns1__CountsByArticleResult *const*)ptr);
		break;
	case SOAP_TYPE_protocolv2_PointerToPointerTons1__CCompteurArticle:
		soap_serialize_PointerToPointerTons1__CCompteurArticle(soap, (ns1__CCompteurArticle **const*)ptr);
		break;
	case SOAP_TYPE_protocolv2_PointerTons1__CCompteurArticle:
		soap_serialize_PointerTons1__CCompteurArticle(soap, (ns1__CCompteurArticle *const*)ptr);
		break;
	case SOAP_TYPE_protocolv2_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_protocolv2_PointerTons1__CCompteurMachine:
		soap_serialize_PointerTons1__CCompteurMachine(soap, (ns1__CCompteurMachine *const*)ptr);
		break;
	case SOAP_TYPE_protocolv2__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_protocolv2_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}

SOAP_FMAC3 void * SOAP_FMAC4 protocolv2_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_protocolv2_ns1__CountsByArticleResult:
		return (void*)soap_instantiate_ns1__CountsByArticleResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2_ns1__CCompteurMoule:
		return (void*)soap_instantiate_ns1__CCompteurMoule(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2_ns1__CCounter:
		return (void*)soap_instantiate_ns1__CCounter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2_ns1__ArrayOfCCompteurArticle:
		return (void*)soap_instantiate_ns1__ArrayOfCCompteurArticle(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__Counts:
		return (void*)soap_instantiate__ns1__Counts(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__CountsResponse:
		return (void*)soap_instantiate__ns1__CountsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__CountsByArticle:
		return (void*)soap_instantiate__ns1__CountsByArticle(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__CountsByArticleResponse:
		return (void*)soap_instantiate__ns1__CountsByArticleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__PreserveCounts:
		return (void*)soap_instantiate__ns1__PreserveCounts(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__PreserveCountsResponse:
		return (void*)soap_instantiate__ns1__PreserveCountsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDate:
		return (void*)soap_instantiate__ns1__GetUpdatedLastRequestDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDateResponse:
		return (void*)soap_instantiate__ns1__GetUpdatedLastRequestDateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__MountedMolds:
		return (void*)soap_instantiate__ns1__MountedMolds(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__MountedMoldsResponse:
		return (void*)soap_instantiate__ns1__MountedMoldsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__EjectedMolds:
		return (void*)soap_instantiate__ns1__EjectedMolds(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__EjectedMoldsResponse:
		return (void*)soap_instantiate__ns1__EjectedMoldsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__ReadenMolds:
		return (void*)soap_instantiate__ns1__ReadenMolds(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__ReadenMoldsResponse:
		return (void*)soap_instantiate__ns1__ReadenMoldsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__Measures:
		return (void*)soap_instantiate__ns1__Measures(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__MeasuresResponse:
		return (void*)soap_instantiate__ns1__MeasuresResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__Alarms:
		return (void*)soap_instantiate__ns1__Alarms(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__AlarmsResponse:
		return (void*)soap_instantiate__ns1__AlarmsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__Samples:
		return (void*)soap_instantiate__ns1__Samples(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__SamplesResponse:
		return (void*)soap_instantiate__ns1__SamplesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__AddMountedMolds:
		return (void*)soap_instantiate__ns1__AddMountedMolds(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__AddMountedMoldsResponse:
		return (void*)soap_instantiate__ns1__AddMountedMoldsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__AddEjectedMolds:
		return (void*)soap_instantiate__ns1__AddEjectedMolds(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__AddEjectedMoldsResponse:
		return (void*)soap_instantiate__ns1__AddEjectedMoldsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__AddSamples:
		return (void*)soap_instantiate__ns1__AddSamples(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__AddSamplesResponse:
		return (void*)soap_instantiate__ns1__AddSamplesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__GetLastRequestDate:
		return (void*)soap_instantiate__ns1__GetLastRequestDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2__ns1__GetLastRequestDateResponse:
		return (void*)soap_instantiate__ns1__GetLastRequestDateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2_ns1__CCompteurMachine:
		return (void*)soap_instantiate_ns1__CCompteurMachine(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2_ns1__CCompteurMouleCapteur:
		return (void*)soap_instantiate_ns1__CCompteurMouleCapteur(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2_ns1__CCompteurArticle:
		return (void*)soap_instantiate_ns1__CCompteurArticle(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__Counts:
		return (void*)soap_instantiate___ns1__Counts(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__CountsByArticle:
		return (void*)soap_instantiate___ns1__CountsByArticle(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__PreserveCounts:
		return (void*)soap_instantiate___ns1__PreserveCounts(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__GetUpdatedLastRequestDate:
		return (void*)soap_instantiate___ns1__GetUpdatedLastRequestDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__MountedMolds:
		return (void*)soap_instantiate___ns1__MountedMolds(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__EjectedMolds:
		return (void*)soap_instantiate___ns1__EjectedMolds(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__ReadenMolds:
		return (void*)soap_instantiate___ns1__ReadenMolds(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__Measures:
		return (void*)soap_instantiate___ns1__Measures(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__Alarms:
		return (void*)soap_instantiate___ns1__Alarms(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__Samples:
		return (void*)soap_instantiate___ns1__Samples(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__AddMountedMolds:
		return (void*)soap_instantiate___ns1__AddMountedMolds(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__AddEjectedMolds:
		return (void*)soap_instantiate___ns1__AddEjectedMolds(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__AddSamples:
		return (void*)soap_instantiate___ns1__AddSamples(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__GetLastRequestDate:
		return (void*)soap_instantiate___ns1__GetLastRequestDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__Counts_:
		return (void*)soap_instantiate___ns1__Counts_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__CountsByArticle_:
		return (void*)soap_instantiate___ns1__CountsByArticle_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__PreserveCounts_:
		return (void*)soap_instantiate___ns1__PreserveCounts_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__GetUpdatedLastRequestDate_:
		return (void*)soap_instantiate___ns1__GetUpdatedLastRequestDate_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__MountedMolds_:
		return (void*)soap_instantiate___ns1__MountedMolds_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__EjectedMolds_:
		return (void*)soap_instantiate___ns1__EjectedMolds_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__ReadenMolds_:
		return (void*)soap_instantiate___ns1__ReadenMolds_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__Measures_:
		return (void*)soap_instantiate___ns1__Measures_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__Alarms_:
		return (void*)soap_instantiate___ns1__Alarms_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__Samples_:
		return (void*)soap_instantiate___ns1__Samples_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__AddMountedMolds_:
		return (void*)soap_instantiate___ns1__AddMountedMolds_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__AddEjectedMolds_:
		return (void*)soap_instantiate___ns1__AddEjectedMolds_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__AddSamples_:
		return (void*)soap_instantiate___ns1__AddSamples_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_protocolv2___ns1__GetLastRequestDate_:
		return (void*)soap_instantiate___ns1__GetLastRequestDate_(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_protocolv2_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_protocolv2_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_protocolv2_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_protocolv2_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_protocolv2_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 protocolv2_fdelete(struct soap *soap, struct soap_clist *p)
{
	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE_protocolv2_ns1__CountsByArticleResult:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__CountsByArticleResult*>(p->ptr), ns1__CountsByArticleResult);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__CountsByArticleResult*>(p->ptr), ns1__CountsByArticleResult);
		break;
	case SOAP_TYPE_protocolv2_ns1__CCompteurMoule:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__CCompteurMoule*>(p->ptr), ns1__CCompteurMoule);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__CCompteurMoule*>(p->ptr), ns1__CCompteurMoule);
		break;
	case SOAP_TYPE_protocolv2_ns1__CCounter:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__CCounter*>(p->ptr), ns1__CCounter);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__CCounter*>(p->ptr), ns1__CCounter);
		break;
	case SOAP_TYPE_protocolv2_ns1__ArrayOfCCompteurArticle:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ArrayOfCCompteurArticle*>(p->ptr), ns1__ArrayOfCCompteurArticle);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ArrayOfCCompteurArticle*>(p->ptr), ns1__ArrayOfCCompteurArticle);
		break;
	case SOAP_TYPE_protocolv2__ns1__Counts:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__Counts*>(p->ptr), _ns1__Counts);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__Counts*>(p->ptr), _ns1__Counts);
		break;
	case SOAP_TYPE_protocolv2__ns1__CountsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__CountsResponse*>(p->ptr), _ns1__CountsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__CountsResponse*>(p->ptr), _ns1__CountsResponse);
		break;
	case SOAP_TYPE_protocolv2__ns1__CountsByArticle:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__CountsByArticle*>(p->ptr), _ns1__CountsByArticle);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__CountsByArticle*>(p->ptr), _ns1__CountsByArticle);
		break;
	case SOAP_TYPE_protocolv2__ns1__CountsByArticleResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__CountsByArticleResponse*>(p->ptr), _ns1__CountsByArticleResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__CountsByArticleResponse*>(p->ptr), _ns1__CountsByArticleResponse);
		break;
	case SOAP_TYPE_protocolv2__ns1__PreserveCounts:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__PreserveCounts*>(p->ptr), _ns1__PreserveCounts);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__PreserveCounts*>(p->ptr), _ns1__PreserveCounts);
		break;
	case SOAP_TYPE_protocolv2__ns1__PreserveCountsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__PreserveCountsResponse*>(p->ptr), _ns1__PreserveCountsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__PreserveCountsResponse*>(p->ptr), _ns1__PreserveCountsResponse);
		break;
	case SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDate:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetUpdatedLastRequestDate*>(p->ptr), _ns1__GetUpdatedLastRequestDate);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetUpdatedLastRequestDate*>(p->ptr), _ns1__GetUpdatedLastRequestDate);
		break;
	case SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDateResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetUpdatedLastRequestDateResponse*>(p->ptr), _ns1__GetUpdatedLastRequestDateResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetUpdatedLastRequestDateResponse*>(p->ptr), _ns1__GetUpdatedLastRequestDateResponse);
		break;
	case SOAP_TYPE_protocolv2__ns1__MountedMolds:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__MountedMolds*>(p->ptr), _ns1__MountedMolds);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__MountedMolds*>(p->ptr), _ns1__MountedMolds);
		break;
	case SOAP_TYPE_protocolv2__ns1__MountedMoldsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__MountedMoldsResponse*>(p->ptr), _ns1__MountedMoldsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__MountedMoldsResponse*>(p->ptr), _ns1__MountedMoldsResponse);
		break;
	case SOAP_TYPE_protocolv2__ns1__EjectedMolds:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__EjectedMolds*>(p->ptr), _ns1__EjectedMolds);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__EjectedMolds*>(p->ptr), _ns1__EjectedMolds);
		break;
	case SOAP_TYPE_protocolv2__ns1__EjectedMoldsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__EjectedMoldsResponse*>(p->ptr), _ns1__EjectedMoldsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__EjectedMoldsResponse*>(p->ptr), _ns1__EjectedMoldsResponse);
		break;
	case SOAP_TYPE_protocolv2__ns1__ReadenMolds:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ReadenMolds*>(p->ptr), _ns1__ReadenMolds);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ReadenMolds*>(p->ptr), _ns1__ReadenMolds);
		break;
	case SOAP_TYPE_protocolv2__ns1__ReadenMoldsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ReadenMoldsResponse*>(p->ptr), _ns1__ReadenMoldsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ReadenMoldsResponse*>(p->ptr), _ns1__ReadenMoldsResponse);
		break;
	case SOAP_TYPE_protocolv2__ns1__Measures:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__Measures*>(p->ptr), _ns1__Measures);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__Measures*>(p->ptr), _ns1__Measures);
		break;
	case SOAP_TYPE_protocolv2__ns1__MeasuresResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__MeasuresResponse*>(p->ptr), _ns1__MeasuresResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__MeasuresResponse*>(p->ptr), _ns1__MeasuresResponse);
		break;
	case SOAP_TYPE_protocolv2__ns1__Alarms:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__Alarms*>(p->ptr), _ns1__Alarms);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__Alarms*>(p->ptr), _ns1__Alarms);
		break;
	case SOAP_TYPE_protocolv2__ns1__AlarmsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__AlarmsResponse*>(p->ptr), _ns1__AlarmsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__AlarmsResponse*>(p->ptr), _ns1__AlarmsResponse);
		break;
	case SOAP_TYPE_protocolv2__ns1__Samples:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__Samples*>(p->ptr), _ns1__Samples);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__Samples*>(p->ptr), _ns1__Samples);
		break;
	case SOAP_TYPE_protocolv2__ns1__SamplesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__SamplesResponse*>(p->ptr), _ns1__SamplesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__SamplesResponse*>(p->ptr), _ns1__SamplesResponse);
		break;
	case SOAP_TYPE_protocolv2__ns1__AddMountedMolds:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__AddMountedMolds*>(p->ptr), _ns1__AddMountedMolds);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__AddMountedMolds*>(p->ptr), _ns1__AddMountedMolds);
		break;
	case SOAP_TYPE_protocolv2__ns1__AddMountedMoldsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__AddMountedMoldsResponse*>(p->ptr), _ns1__AddMountedMoldsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__AddMountedMoldsResponse*>(p->ptr), _ns1__AddMountedMoldsResponse);
		break;
	case SOAP_TYPE_protocolv2__ns1__AddEjectedMolds:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__AddEjectedMolds*>(p->ptr), _ns1__AddEjectedMolds);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__AddEjectedMolds*>(p->ptr), _ns1__AddEjectedMolds);
		break;
	case SOAP_TYPE_protocolv2__ns1__AddEjectedMoldsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__AddEjectedMoldsResponse*>(p->ptr), _ns1__AddEjectedMoldsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__AddEjectedMoldsResponse*>(p->ptr), _ns1__AddEjectedMoldsResponse);
		break;
	case SOAP_TYPE_protocolv2__ns1__AddSamples:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__AddSamples*>(p->ptr), _ns1__AddSamples);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__AddSamples*>(p->ptr), _ns1__AddSamples);
		break;
	case SOAP_TYPE_protocolv2__ns1__AddSamplesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__AddSamplesResponse*>(p->ptr), _ns1__AddSamplesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__AddSamplesResponse*>(p->ptr), _ns1__AddSamplesResponse);
		break;
	case SOAP_TYPE_protocolv2__ns1__GetLastRequestDate:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetLastRequestDate*>(p->ptr), _ns1__GetLastRequestDate);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetLastRequestDate*>(p->ptr), _ns1__GetLastRequestDate);
		break;
	case SOAP_TYPE_protocolv2__ns1__GetLastRequestDateResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetLastRequestDateResponse*>(p->ptr), _ns1__GetLastRequestDateResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetLastRequestDateResponse*>(p->ptr), _ns1__GetLastRequestDateResponse);
		break;
	case SOAP_TYPE_protocolv2_ns1__CCompteurMachine:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__CCompteurMachine*>(p->ptr), ns1__CCompteurMachine);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__CCompteurMachine*>(p->ptr), ns1__CCompteurMachine);
		break;
	case SOAP_TYPE_protocolv2_ns1__CCompteurMouleCapteur:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__CCompteurMouleCapteur*>(p->ptr), ns1__CCompteurMouleCapteur);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__CCompteurMouleCapteur*>(p->ptr), ns1__CCompteurMouleCapteur);
		break;
	case SOAP_TYPE_protocolv2_ns1__CCompteurArticle:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__CCompteurArticle*>(p->ptr), ns1__CCompteurArticle);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__CCompteurArticle*>(p->ptr), ns1__CCompteurArticle);
		break;
	case SOAP_TYPE_protocolv2___ns1__Counts:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Counts*>(p->ptr), struct __ns1__Counts);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Counts*>(p->ptr), struct __ns1__Counts);
		break;
	case SOAP_TYPE_protocolv2___ns1__CountsByArticle:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__CountsByArticle*>(p->ptr), struct __ns1__CountsByArticle);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__CountsByArticle*>(p->ptr), struct __ns1__CountsByArticle);
		break;
	case SOAP_TYPE_protocolv2___ns1__PreserveCounts:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__PreserveCounts*>(p->ptr), struct __ns1__PreserveCounts);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__PreserveCounts*>(p->ptr), struct __ns1__PreserveCounts);
		break;
	case SOAP_TYPE_protocolv2___ns1__GetUpdatedLastRequestDate:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetUpdatedLastRequestDate*>(p->ptr), struct __ns1__GetUpdatedLastRequestDate);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetUpdatedLastRequestDate*>(p->ptr), struct __ns1__GetUpdatedLastRequestDate);
		break;
	case SOAP_TYPE_protocolv2___ns1__MountedMolds:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__MountedMolds*>(p->ptr), struct __ns1__MountedMolds);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__MountedMolds*>(p->ptr), struct __ns1__MountedMolds);
		break;
	case SOAP_TYPE_protocolv2___ns1__EjectedMolds:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__EjectedMolds*>(p->ptr), struct __ns1__EjectedMolds);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__EjectedMolds*>(p->ptr), struct __ns1__EjectedMolds);
		break;
	case SOAP_TYPE_protocolv2___ns1__ReadenMolds:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ReadenMolds*>(p->ptr), struct __ns1__ReadenMolds);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ReadenMolds*>(p->ptr), struct __ns1__ReadenMolds);
		break;
	case SOAP_TYPE_protocolv2___ns1__Measures:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Measures*>(p->ptr), struct __ns1__Measures);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Measures*>(p->ptr), struct __ns1__Measures);
		break;
	case SOAP_TYPE_protocolv2___ns1__Alarms:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Alarms*>(p->ptr), struct __ns1__Alarms);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Alarms*>(p->ptr), struct __ns1__Alarms);
		break;
	case SOAP_TYPE_protocolv2___ns1__Samples:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Samples*>(p->ptr), struct __ns1__Samples);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Samples*>(p->ptr), struct __ns1__Samples);
		break;
	case SOAP_TYPE_protocolv2___ns1__AddMountedMolds:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__AddMountedMolds*>(p->ptr), struct __ns1__AddMountedMolds);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__AddMountedMolds*>(p->ptr), struct __ns1__AddMountedMolds);
		break;
	case SOAP_TYPE_protocolv2___ns1__AddEjectedMolds:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__AddEjectedMolds*>(p->ptr), struct __ns1__AddEjectedMolds);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__AddEjectedMolds*>(p->ptr), struct __ns1__AddEjectedMolds);
		break;
	case SOAP_TYPE_protocolv2___ns1__AddSamples:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__AddSamples*>(p->ptr), struct __ns1__AddSamples);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__AddSamples*>(p->ptr), struct __ns1__AddSamples);
		break;
	case SOAP_TYPE_protocolv2___ns1__GetLastRequestDate:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetLastRequestDate*>(p->ptr), struct __ns1__GetLastRequestDate);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetLastRequestDate*>(p->ptr), struct __ns1__GetLastRequestDate);
		break;
	case SOAP_TYPE_protocolv2___ns1__Counts_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Counts_*>(p->ptr), struct __ns1__Counts_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Counts_*>(p->ptr), struct __ns1__Counts_);
		break;
	case SOAP_TYPE_protocolv2___ns1__CountsByArticle_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__CountsByArticle_*>(p->ptr), struct __ns1__CountsByArticle_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__CountsByArticle_*>(p->ptr), struct __ns1__CountsByArticle_);
		break;
	case SOAP_TYPE_protocolv2___ns1__PreserveCounts_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__PreserveCounts_*>(p->ptr), struct __ns1__PreserveCounts_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__PreserveCounts_*>(p->ptr), struct __ns1__PreserveCounts_);
		break;
	case SOAP_TYPE_protocolv2___ns1__GetUpdatedLastRequestDate_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetUpdatedLastRequestDate_*>(p->ptr), struct __ns1__GetUpdatedLastRequestDate_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetUpdatedLastRequestDate_*>(p->ptr), struct __ns1__GetUpdatedLastRequestDate_);
		break;
	case SOAP_TYPE_protocolv2___ns1__MountedMolds_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__MountedMolds_*>(p->ptr), struct __ns1__MountedMolds_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__MountedMolds_*>(p->ptr), struct __ns1__MountedMolds_);
		break;
	case SOAP_TYPE_protocolv2___ns1__EjectedMolds_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__EjectedMolds_*>(p->ptr), struct __ns1__EjectedMolds_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__EjectedMolds_*>(p->ptr), struct __ns1__EjectedMolds_);
		break;
	case SOAP_TYPE_protocolv2___ns1__ReadenMolds_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ReadenMolds_*>(p->ptr), struct __ns1__ReadenMolds_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ReadenMolds_*>(p->ptr), struct __ns1__ReadenMolds_);
		break;
	case SOAP_TYPE_protocolv2___ns1__Measures_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Measures_*>(p->ptr), struct __ns1__Measures_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Measures_*>(p->ptr), struct __ns1__Measures_);
		break;
	case SOAP_TYPE_protocolv2___ns1__Alarms_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Alarms_*>(p->ptr), struct __ns1__Alarms_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Alarms_*>(p->ptr), struct __ns1__Alarms_);
		break;
	case SOAP_TYPE_protocolv2___ns1__Samples_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Samples_*>(p->ptr), struct __ns1__Samples_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Samples_*>(p->ptr), struct __ns1__Samples_);
		break;
	case SOAP_TYPE_protocolv2___ns1__AddMountedMolds_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__AddMountedMolds_*>(p->ptr), struct __ns1__AddMountedMolds_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__AddMountedMolds_*>(p->ptr), struct __ns1__AddMountedMolds_);
		break;
	case SOAP_TYPE_protocolv2___ns1__AddEjectedMolds_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__AddEjectedMolds_*>(p->ptr), struct __ns1__AddEjectedMolds_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__AddEjectedMolds_*>(p->ptr), struct __ns1__AddEjectedMolds_);
		break;
	case SOAP_TYPE_protocolv2___ns1__AddSamples_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__AddSamples_*>(p->ptr), struct __ns1__AddSamples_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__AddSamples_*>(p->ptr), struct __ns1__AddSamples_);
		break;
	case SOAP_TYPE_protocolv2___ns1__GetLastRequestDate_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetLastRequestDate_*>(p->ptr), struct __ns1__GetLastRequestDate_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetLastRequestDate_*>(p->ptr), struct __ns1__GetLastRequestDate_);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_protocolv2_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_protocolv2_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_protocolv2_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_protocolv2_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_protocolv2_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		break;
#endif
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 protocolv2_fbase(int t, int b)
{
	do
	{	switch (t)
		{

		case SOAP_TYPE_protocolv2_ns1__CCompteurMachine: t = SOAP_TYPE_protocolv2_ns1__CCompteurMoule; break;
		case SOAP_TYPE_protocolv2_ns1__CCompteurMouleCapteur: t = SOAP_TYPE_protocolv2_ns1__CCompteurMoule; break;
		case SOAP_TYPE_protocolv2_ns1__CCompteurArticle: t = SOAP_TYPE_protocolv2_ns1__CCompteurMoule; break;
		default: return 0;
		}
	}
	while (t != b);
	return 1;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 protocolv2_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_protocolv2_ns1__CountsByArticleResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__CountsByArticleResult type=%d location=%p object=%p\n", t, p, q));
		*(ns1__CountsByArticleResult*)p = *(ns1__CountsByArticleResult*)q;
		break;
	case SOAP_TYPE_protocolv2_ns1__CCompteurMoule:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__CCompteurMoule type=%d location=%p object=%p\n", t, p, q));
		*(ns1__CCompteurMoule*)p = *(ns1__CCompteurMoule*)q;
		break;
	case SOAP_TYPE_protocolv2_ns1__CCounter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__CCounter type=%d location=%p object=%p\n", t, p, q));
		*(ns1__CCounter*)p = *(ns1__CCounter*)q;
		break;
	case SOAP_TYPE_protocolv2_ns1__ArrayOfCCompteurArticle:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfCCompteurArticle type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfCCompteurArticle*)p = *(ns1__ArrayOfCCompteurArticle*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__Counts:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Counts type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Counts*)p = *(_ns1__Counts*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__CountsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CountsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CountsResponse*)p = *(_ns1__CountsResponse*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__CountsByArticle:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CountsByArticle type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CountsByArticle*)p = *(_ns1__CountsByArticle*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__CountsByArticleResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CountsByArticleResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CountsByArticleResponse*)p = *(_ns1__CountsByArticleResponse*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__PreserveCounts:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__PreserveCounts type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__PreserveCounts*)p = *(_ns1__PreserveCounts*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__PreserveCountsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__PreserveCountsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__PreserveCountsResponse*)p = *(_ns1__PreserveCountsResponse*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetUpdatedLastRequestDate type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetUpdatedLastRequestDate*)p = *(_ns1__GetUpdatedLastRequestDate*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDateResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetUpdatedLastRequestDateResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetUpdatedLastRequestDateResponse*)p = *(_ns1__GetUpdatedLastRequestDateResponse*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__MountedMolds:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__MountedMolds type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__MountedMolds*)p = *(_ns1__MountedMolds*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__MountedMoldsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__MountedMoldsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__MountedMoldsResponse*)p = *(_ns1__MountedMoldsResponse*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__EjectedMolds:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__EjectedMolds type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__EjectedMolds*)p = *(_ns1__EjectedMolds*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__EjectedMoldsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__EjectedMoldsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__EjectedMoldsResponse*)p = *(_ns1__EjectedMoldsResponse*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__ReadenMolds:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ReadenMolds type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ReadenMolds*)p = *(_ns1__ReadenMolds*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__ReadenMoldsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ReadenMoldsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ReadenMoldsResponse*)p = *(_ns1__ReadenMoldsResponse*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__Measures:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Measures type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Measures*)p = *(_ns1__Measures*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__MeasuresResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__MeasuresResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__MeasuresResponse*)p = *(_ns1__MeasuresResponse*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__Alarms:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Alarms type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Alarms*)p = *(_ns1__Alarms*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__AlarmsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__AlarmsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__AlarmsResponse*)p = *(_ns1__AlarmsResponse*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__Samples:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Samples type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Samples*)p = *(_ns1__Samples*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__SamplesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SamplesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SamplesResponse*)p = *(_ns1__SamplesResponse*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__AddMountedMolds:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__AddMountedMolds type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__AddMountedMolds*)p = *(_ns1__AddMountedMolds*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__AddMountedMoldsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__AddMountedMoldsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__AddMountedMoldsResponse*)p = *(_ns1__AddMountedMoldsResponse*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__AddEjectedMolds:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__AddEjectedMolds type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__AddEjectedMolds*)p = *(_ns1__AddEjectedMolds*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__AddEjectedMoldsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__AddEjectedMoldsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__AddEjectedMoldsResponse*)p = *(_ns1__AddEjectedMoldsResponse*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__AddSamples:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__AddSamples type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__AddSamples*)p = *(_ns1__AddSamples*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__AddSamplesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__AddSamplesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__AddSamplesResponse*)p = *(_ns1__AddSamplesResponse*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__GetLastRequestDate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetLastRequestDate type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetLastRequestDate*)p = *(_ns1__GetLastRequestDate*)q;
		break;
	case SOAP_TYPE_protocolv2__ns1__GetLastRequestDateResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetLastRequestDateResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetLastRequestDateResponse*)p = *(_ns1__GetLastRequestDateResponse*)q;
		break;
	case SOAP_TYPE_protocolv2_ns1__CCompteurMachine:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__CCompteurMachine type=%d location=%p object=%p\n", t, p, q));
		*(ns1__CCompteurMachine*)p = *(ns1__CCompteurMachine*)q;
		break;
	case SOAP_TYPE_protocolv2_ns1__CCompteurMouleCapteur:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__CCompteurMouleCapteur type=%d location=%p object=%p\n", t, p, q));
		*(ns1__CCompteurMouleCapteur*)p = *(ns1__CCompteurMouleCapteur*)q;
		break;
	case SOAP_TYPE_protocolv2_ns1__CCompteurArticle:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__CCompteurArticle type=%d location=%p object=%p\n", t, p, q));
		*(ns1__CCompteurArticle*)p = *(ns1__CCompteurArticle*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__Counts:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Counts type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Counts*)p = *(struct __ns1__Counts*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__CountsByArticle:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CountsByArticle type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CountsByArticle*)p = *(struct __ns1__CountsByArticle*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__PreserveCounts:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__PreserveCounts type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__PreserveCounts*)p = *(struct __ns1__PreserveCounts*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__GetUpdatedLastRequestDate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetUpdatedLastRequestDate type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetUpdatedLastRequestDate*)p = *(struct __ns1__GetUpdatedLastRequestDate*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__MountedMolds:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__MountedMolds type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__MountedMolds*)p = *(struct __ns1__MountedMolds*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__EjectedMolds:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__EjectedMolds type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__EjectedMolds*)p = *(struct __ns1__EjectedMolds*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__ReadenMolds:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ReadenMolds type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ReadenMolds*)p = *(struct __ns1__ReadenMolds*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__Measures:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Measures type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Measures*)p = *(struct __ns1__Measures*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__Alarms:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Alarms type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Alarms*)p = *(struct __ns1__Alarms*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__Samples:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Samples type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Samples*)p = *(struct __ns1__Samples*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__AddMountedMolds:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__AddMountedMolds type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__AddMountedMolds*)p = *(struct __ns1__AddMountedMolds*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__AddEjectedMolds:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__AddEjectedMolds type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__AddEjectedMolds*)p = *(struct __ns1__AddEjectedMolds*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__AddSamples:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__AddSamples type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__AddSamples*)p = *(struct __ns1__AddSamples*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__GetLastRequestDate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetLastRequestDate type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetLastRequestDate*)p = *(struct __ns1__GetLastRequestDate*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__Counts_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Counts_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Counts_*)p = *(struct __ns1__Counts_*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__CountsByArticle_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CountsByArticle_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CountsByArticle_*)p = *(struct __ns1__CountsByArticle_*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__PreserveCounts_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__PreserveCounts_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__PreserveCounts_*)p = *(struct __ns1__PreserveCounts_*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__GetUpdatedLastRequestDate_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetUpdatedLastRequestDate_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetUpdatedLastRequestDate_*)p = *(struct __ns1__GetUpdatedLastRequestDate_*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__MountedMolds_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__MountedMolds_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__MountedMolds_*)p = *(struct __ns1__MountedMolds_*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__EjectedMolds_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__EjectedMolds_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__EjectedMolds_*)p = *(struct __ns1__EjectedMolds_*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__ReadenMolds_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ReadenMolds_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ReadenMolds_*)p = *(struct __ns1__ReadenMolds_*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__Measures_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Measures_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Measures_*)p = *(struct __ns1__Measures_*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__Alarms_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Alarms_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Alarms_*)p = *(struct __ns1__Alarms_*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__Samples_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Samples_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Samples_*)p = *(struct __ns1__Samples_*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__AddMountedMolds_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__AddMountedMolds_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__AddMountedMolds_*)p = *(struct __ns1__AddMountedMolds_*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__AddEjectedMolds_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__AddEjectedMolds_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__AddEjectedMolds_*)p = *(struct __ns1__AddEjectedMolds_*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__AddSamples_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__AddSamples_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__AddSamples_*)p = *(struct __ns1__AddSamples_*)q;
		break;
	case SOAP_TYPE_protocolv2___ns1__GetLastRequestDate_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetLastRequestDate_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetLastRequestDate_*)p = *(struct __ns1__GetLastRequestDate_*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_protocolv2_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_protocolv2_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_protocolv2_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_protocolv2_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_protocolv2_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_protocolv2_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_protocolv2_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_protocolv2_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_protocolv2_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_protocolv2_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_protocolv2_dateTime);
	return a;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_dateTime(struct soap *soap, int n)
{
	time_t *a = static_cast<time_t *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(time_t)));
	for (time_t *p = a; p && n--; ++p)
		soap_default_dateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetLastRequestDateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_dateTime(soap, &this->_ns1__GetLastRequestDateResponse::GetLastRequestDateResult);
}

void _ns1__GetLastRequestDateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetLastRequestDateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLastRequestDateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLastRequestDateResponse(struct soap *soap, const char *tag, int id, const _ns1__GetLastRequestDateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__GetLastRequestDateResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:GetLastRequestDateResult");
	if (soap_out_dateTime(soap, "ns1:GetLastRequestDateResult", -1, &a->_ns1__GetLastRequestDateResponse::GetLastRequestDateResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLastRequestDateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__GetLastRequestDateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLastRequestDateResponse * SOAP_FMAC4 soap_in__ns1__GetLastRequestDateResponse(struct soap *soap, const char *tag, _ns1__GetLastRequestDateResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLastRequestDateResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__GetLastRequestDateResponse, sizeof(_ns1__GetLastRequestDateResponse), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__GetLastRequestDateResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetLastRequestDateResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetLastRequestDateResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetLastRequestDateResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:GetLastRequestDateResult", &a->_ns1__GetLastRequestDateResponse::GetLastRequestDateResult, "xsd:dateTime"))
				{	soap_flag_GetLastRequestDateResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetLastRequestDateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetLastRequestDateResult1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetLastRequestDateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__GetLastRequestDateResponse, SOAP_TYPE_protocolv2__ns1__GetLastRequestDateResponse, sizeof(_ns1__GetLastRequestDateResponse), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetLastRequestDateResponse * SOAP_FMAC2 soap_instantiate__ns1__GetLastRequestDateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLastRequestDateResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetLastRequestDateResponse *p;
	size_t k = sizeof(_ns1__GetLastRequestDateResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__GetLastRequestDateResponse, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetLastRequestDateResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetLastRequestDateResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetLastRequestDateResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetLastRequestDateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetLastRequestDateResponse(soap, tag ? tag : "ns1:GetLastRequestDateResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLastRequestDateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLastRequestDateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLastRequestDateResponse * SOAP_FMAC4 soap_get__ns1__GetLastRequestDateResponse(struct soap *soap, _ns1__GetLastRequestDateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLastRequestDateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetLastRequestDate::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetLastRequestDate::functionNumber);
}

void _ns1__GetLastRequestDate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__GetLastRequestDate::functionNumber, SOAP_TYPE_protocolv2_int);
#endif
}

int _ns1__GetLastRequestDate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLastRequestDate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLastRequestDate(struct soap *soap, const char *tag, int id, const _ns1__GetLastRequestDate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__GetLastRequestDate), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:functionNumber", -1, &a->_ns1__GetLastRequestDate::functionNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLastRequestDate::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__GetLastRequestDate(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLastRequestDate * SOAP_FMAC4 soap_in__ns1__GetLastRequestDate(struct soap *soap, const char *tag, _ns1__GetLastRequestDate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLastRequestDate*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__GetLastRequestDate, sizeof(_ns1__GetLastRequestDate), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__GetLastRequestDate)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetLastRequestDate *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_functionNumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_functionNumber1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:functionNumber", &a->_ns1__GetLastRequestDate::functionNumber, "xsd:int"))
				{	soap_flag_functionNumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_functionNumber1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetLastRequestDate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__GetLastRequestDate, SOAP_TYPE_protocolv2__ns1__GetLastRequestDate, sizeof(_ns1__GetLastRequestDate), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetLastRequestDate * SOAP_FMAC2 soap_instantiate__ns1__GetLastRequestDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLastRequestDate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetLastRequestDate *p;
	size_t k = sizeof(_ns1__GetLastRequestDate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__GetLastRequestDate, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetLastRequestDate);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetLastRequestDate, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetLastRequestDate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetLastRequestDate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetLastRequestDate(soap, tag ? tag : "ns1:GetLastRequestDate", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLastRequestDate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLastRequestDate(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLastRequestDate * SOAP_FMAC4 soap_get__ns1__GetLastRequestDate(struct soap *soap, _ns1__GetLastRequestDate *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLastRequestDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__AddSamplesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__AddSamplesResponse::AddSamplesResult);
}

void _ns1__AddSamplesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__AddSamplesResponse::AddSamplesResult);
#endif
}

int _ns1__AddSamplesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddSamplesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddSamplesResponse(struct soap *soap, const char *tag, int id, const _ns1__AddSamplesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__AddSamplesResponse), type))
		return soap->error;
	if (a->AddSamplesResult)
		soap_element_result(soap, "ns1:AddSamplesResult");
	if (soap_out_string(soap, "ns1:AddSamplesResult", -1, (char*const*)&a->_ns1__AddSamplesResponse::AddSamplesResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddSamplesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__AddSamplesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddSamplesResponse * SOAP_FMAC4 soap_in__ns1__AddSamplesResponse(struct soap *soap, const char *tag, _ns1__AddSamplesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddSamplesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__AddSamplesResponse, sizeof(_ns1__AddSamplesResponse), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__AddSamplesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__AddSamplesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AddSamplesResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AddSamplesResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:AddSamplesResult", (char**)&a->_ns1__AddSamplesResponse::AddSamplesResult, "xsd:string"))
				{	soap_flag_AddSamplesResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:AddSamplesResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AddSamplesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__AddSamplesResponse, SOAP_TYPE_protocolv2__ns1__AddSamplesResponse, sizeof(_ns1__AddSamplesResponse), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__AddSamplesResponse * SOAP_FMAC2 soap_instantiate__ns1__AddSamplesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddSamplesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__AddSamplesResponse *p;
	size_t k = sizeof(_ns1__AddSamplesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__AddSamplesResponse, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__AddSamplesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__AddSamplesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__AddSamplesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__AddSamplesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__AddSamplesResponse(soap, tag ? tag : "ns1:AddSamplesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AddSamplesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddSamplesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddSamplesResponse * SOAP_FMAC4 soap_get__ns1__AddSamplesResponse(struct soap *soap, _ns1__AddSamplesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddSamplesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__AddSamples::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__AddSamples::samples);
}

void _ns1__AddSamples::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__AddSamples::samples);
#endif
}

int _ns1__AddSamples::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddSamples(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddSamples(struct soap *soap, const char *tag, int id, const _ns1__AddSamples *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__AddSamples), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:samples", -1, (char*const*)&a->_ns1__AddSamples::samples, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddSamples::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__AddSamples(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddSamples * SOAP_FMAC4 soap_in__ns1__AddSamples(struct soap *soap, const char *tag, _ns1__AddSamples *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddSamples*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__AddSamples, sizeof(_ns1__AddSamples), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__AddSamples)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__AddSamples *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_samples1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_samples1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:samples", (char**)&a->_ns1__AddSamples::samples, "xsd:string"))
				{	soap_flag_samples1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AddSamples *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__AddSamples, SOAP_TYPE_protocolv2__ns1__AddSamples, sizeof(_ns1__AddSamples), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__AddSamples * SOAP_FMAC2 soap_instantiate__ns1__AddSamples(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddSamples(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__AddSamples *p;
	size_t k = sizeof(_ns1__AddSamples);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__AddSamples, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__AddSamples);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__AddSamples, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__AddSamples location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__AddSamples::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__AddSamples(soap, tag ? tag : "ns1:AddSamples", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AddSamples::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddSamples(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddSamples * SOAP_FMAC4 soap_get__ns1__AddSamples(struct soap *soap, _ns1__AddSamples *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddSamples(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__AddEjectedMoldsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__AddEjectedMoldsResponse::AddEjectedMoldsResult);
}

void _ns1__AddEjectedMoldsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__AddEjectedMoldsResponse::AddEjectedMoldsResult);
#endif
}

int _ns1__AddEjectedMoldsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddEjectedMoldsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddEjectedMoldsResponse(struct soap *soap, const char *tag, int id, const _ns1__AddEjectedMoldsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__AddEjectedMoldsResponse), type))
		return soap->error;
	if (a->AddEjectedMoldsResult)
		soap_element_result(soap, "ns1:AddEjectedMoldsResult");
	if (soap_out_string(soap, "ns1:AddEjectedMoldsResult", -1, (char*const*)&a->_ns1__AddEjectedMoldsResponse::AddEjectedMoldsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddEjectedMoldsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__AddEjectedMoldsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddEjectedMoldsResponse * SOAP_FMAC4 soap_in__ns1__AddEjectedMoldsResponse(struct soap *soap, const char *tag, _ns1__AddEjectedMoldsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddEjectedMoldsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__AddEjectedMoldsResponse, sizeof(_ns1__AddEjectedMoldsResponse), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__AddEjectedMoldsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__AddEjectedMoldsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AddEjectedMoldsResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AddEjectedMoldsResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:AddEjectedMoldsResult", (char**)&a->_ns1__AddEjectedMoldsResponse::AddEjectedMoldsResult, "xsd:string"))
				{	soap_flag_AddEjectedMoldsResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:AddEjectedMoldsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AddEjectedMoldsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__AddEjectedMoldsResponse, SOAP_TYPE_protocolv2__ns1__AddEjectedMoldsResponse, sizeof(_ns1__AddEjectedMoldsResponse), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__AddEjectedMoldsResponse * SOAP_FMAC2 soap_instantiate__ns1__AddEjectedMoldsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddEjectedMoldsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__AddEjectedMoldsResponse *p;
	size_t k = sizeof(_ns1__AddEjectedMoldsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__AddEjectedMoldsResponse, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__AddEjectedMoldsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__AddEjectedMoldsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__AddEjectedMoldsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__AddEjectedMoldsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__AddEjectedMoldsResponse(soap, tag ? tag : "ns1:AddEjectedMoldsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AddEjectedMoldsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddEjectedMoldsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddEjectedMoldsResponse * SOAP_FMAC4 soap_get__ns1__AddEjectedMoldsResponse(struct soap *soap, _ns1__AddEjectedMoldsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddEjectedMoldsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__AddEjectedMolds::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__AddEjectedMolds::ejectedMolds);
}

void _ns1__AddEjectedMolds::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__AddEjectedMolds::ejectedMolds);
#endif
}

int _ns1__AddEjectedMolds::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddEjectedMolds(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddEjectedMolds(struct soap *soap, const char *tag, int id, const _ns1__AddEjectedMolds *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__AddEjectedMolds), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:ejectedMolds", -1, (char*const*)&a->_ns1__AddEjectedMolds::ejectedMolds, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddEjectedMolds::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__AddEjectedMolds(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddEjectedMolds * SOAP_FMAC4 soap_in__ns1__AddEjectedMolds(struct soap *soap, const char *tag, _ns1__AddEjectedMolds *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddEjectedMolds*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__AddEjectedMolds, sizeof(_ns1__AddEjectedMolds), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__AddEjectedMolds)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__AddEjectedMolds *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ejectedMolds1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ejectedMolds1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:ejectedMolds", (char**)&a->_ns1__AddEjectedMolds::ejectedMolds, "xsd:string"))
				{	soap_flag_ejectedMolds1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AddEjectedMolds *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__AddEjectedMolds, SOAP_TYPE_protocolv2__ns1__AddEjectedMolds, sizeof(_ns1__AddEjectedMolds), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__AddEjectedMolds * SOAP_FMAC2 soap_instantiate__ns1__AddEjectedMolds(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddEjectedMolds(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__AddEjectedMolds *p;
	size_t k = sizeof(_ns1__AddEjectedMolds);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__AddEjectedMolds, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__AddEjectedMolds);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__AddEjectedMolds, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__AddEjectedMolds location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__AddEjectedMolds::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__AddEjectedMolds(soap, tag ? tag : "ns1:AddEjectedMolds", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AddEjectedMolds::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddEjectedMolds(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddEjectedMolds * SOAP_FMAC4 soap_get__ns1__AddEjectedMolds(struct soap *soap, _ns1__AddEjectedMolds *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddEjectedMolds(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__AddMountedMoldsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__AddMountedMoldsResponse::AddMountedMoldsResult);
}

void _ns1__AddMountedMoldsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__AddMountedMoldsResponse::AddMountedMoldsResult);
#endif
}

int _ns1__AddMountedMoldsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddMountedMoldsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddMountedMoldsResponse(struct soap *soap, const char *tag, int id, const _ns1__AddMountedMoldsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__AddMountedMoldsResponse), type))
		return soap->error;
	if (a->AddMountedMoldsResult)
		soap_element_result(soap, "ns1:AddMountedMoldsResult");
	if (soap_out_string(soap, "ns1:AddMountedMoldsResult", -1, (char*const*)&a->_ns1__AddMountedMoldsResponse::AddMountedMoldsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddMountedMoldsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__AddMountedMoldsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddMountedMoldsResponse * SOAP_FMAC4 soap_in__ns1__AddMountedMoldsResponse(struct soap *soap, const char *tag, _ns1__AddMountedMoldsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddMountedMoldsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__AddMountedMoldsResponse, sizeof(_ns1__AddMountedMoldsResponse), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__AddMountedMoldsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__AddMountedMoldsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AddMountedMoldsResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AddMountedMoldsResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:AddMountedMoldsResult", (char**)&a->_ns1__AddMountedMoldsResponse::AddMountedMoldsResult, "xsd:string"))
				{	soap_flag_AddMountedMoldsResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:AddMountedMoldsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AddMountedMoldsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__AddMountedMoldsResponse, SOAP_TYPE_protocolv2__ns1__AddMountedMoldsResponse, sizeof(_ns1__AddMountedMoldsResponse), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__AddMountedMoldsResponse * SOAP_FMAC2 soap_instantiate__ns1__AddMountedMoldsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddMountedMoldsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__AddMountedMoldsResponse *p;
	size_t k = sizeof(_ns1__AddMountedMoldsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__AddMountedMoldsResponse, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__AddMountedMoldsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__AddMountedMoldsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__AddMountedMoldsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__AddMountedMoldsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__AddMountedMoldsResponse(soap, tag ? tag : "ns1:AddMountedMoldsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AddMountedMoldsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddMountedMoldsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddMountedMoldsResponse * SOAP_FMAC4 soap_get__ns1__AddMountedMoldsResponse(struct soap *soap, _ns1__AddMountedMoldsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddMountedMoldsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__AddMountedMolds::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__AddMountedMolds::mountedMolds);
}

void _ns1__AddMountedMolds::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__AddMountedMolds::mountedMolds);
#endif
}

int _ns1__AddMountedMolds::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddMountedMolds(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddMountedMolds(struct soap *soap, const char *tag, int id, const _ns1__AddMountedMolds *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__AddMountedMolds), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:mountedMolds", -1, (char*const*)&a->_ns1__AddMountedMolds::mountedMolds, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddMountedMolds::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__AddMountedMolds(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddMountedMolds * SOAP_FMAC4 soap_in__ns1__AddMountedMolds(struct soap *soap, const char *tag, _ns1__AddMountedMolds *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddMountedMolds*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__AddMountedMolds, sizeof(_ns1__AddMountedMolds), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__AddMountedMolds)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__AddMountedMolds *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_mountedMolds1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mountedMolds1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:mountedMolds", (char**)&a->_ns1__AddMountedMolds::mountedMolds, "xsd:string"))
				{	soap_flag_mountedMolds1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AddMountedMolds *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__AddMountedMolds, SOAP_TYPE_protocolv2__ns1__AddMountedMolds, sizeof(_ns1__AddMountedMolds), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__AddMountedMolds * SOAP_FMAC2 soap_instantiate__ns1__AddMountedMolds(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddMountedMolds(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__AddMountedMolds *p;
	size_t k = sizeof(_ns1__AddMountedMolds);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__AddMountedMolds, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__AddMountedMolds);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__AddMountedMolds, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__AddMountedMolds location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__AddMountedMolds::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__AddMountedMolds(soap, tag ? tag : "ns1:AddMountedMolds", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AddMountedMolds::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddMountedMolds(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddMountedMolds * SOAP_FMAC4 soap_get__ns1__AddMountedMolds(struct soap *soap, _ns1__AddMountedMolds *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddMountedMolds(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SamplesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SamplesResponse::SamplesResult);
}

void _ns1__SamplesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__SamplesResponse::SamplesResult);
#endif
}

int _ns1__SamplesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SamplesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SamplesResponse(struct soap *soap, const char *tag, int id, const _ns1__SamplesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__SamplesResponse), type))
		return soap->error;
	if (a->SamplesResult)
		soap_element_result(soap, "ns1:SamplesResult");
	if (soap_out_string(soap, "ns1:SamplesResult", -1, (char*const*)&a->_ns1__SamplesResponse::SamplesResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SamplesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__SamplesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SamplesResponse * SOAP_FMAC4 soap_in__ns1__SamplesResponse(struct soap *soap, const char *tag, _ns1__SamplesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SamplesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__SamplesResponse, sizeof(_ns1__SamplesResponse), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__SamplesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SamplesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SamplesResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SamplesResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:SamplesResult", (char**)&a->_ns1__SamplesResponse::SamplesResult, "xsd:string"))
				{	soap_flag_SamplesResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:SamplesResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SamplesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__SamplesResponse, SOAP_TYPE_protocolv2__ns1__SamplesResponse, sizeof(_ns1__SamplesResponse), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SamplesResponse * SOAP_FMAC2 soap_instantiate__ns1__SamplesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SamplesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SamplesResponse *p;
	size_t k = sizeof(_ns1__SamplesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__SamplesResponse, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__SamplesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__SamplesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SamplesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__SamplesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SamplesResponse(soap, tag ? tag : "ns1:SamplesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SamplesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SamplesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SamplesResponse * SOAP_FMAC4 soap_get__ns1__SamplesResponse(struct soap *soap, _ns1__SamplesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SamplesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Samples::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _ns1__Samples::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__Samples::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Samples(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Samples(struct soap *soap, const char *tag, int id, const _ns1__Samples *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__Samples), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Samples::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__Samples(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Samples * SOAP_FMAC4 soap_in__ns1__Samples(struct soap *soap, const char *tag, _ns1__Samples *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Samples*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__Samples, sizeof(_ns1__Samples), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__Samples)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__Samples *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Samples *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__Samples, SOAP_TYPE_protocolv2__ns1__Samples, sizeof(_ns1__Samples), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Samples * SOAP_FMAC2 soap_instantiate__ns1__Samples(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Samples(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Samples *p;
	size_t k = sizeof(_ns1__Samples);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__Samples, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__Samples);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__Samples, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Samples location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__Samples::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__Samples(soap, tag ? tag : "ns1:Samples", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Samples::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Samples(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Samples * SOAP_FMAC4 soap_get__ns1__Samples(struct soap *soap, _ns1__Samples *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Samples(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__AlarmsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__AlarmsResponse::AlarmsResult);
}

void _ns1__AlarmsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__AlarmsResponse::AlarmsResult);
#endif
}

int _ns1__AlarmsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AlarmsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AlarmsResponse(struct soap *soap, const char *tag, int id, const _ns1__AlarmsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__AlarmsResponse), type))
		return soap->error;
	if (a->AlarmsResult)
		soap_element_result(soap, "ns1:AlarmsResult");
	if (soap_out_string(soap, "ns1:AlarmsResult", -1, (char*const*)&a->_ns1__AlarmsResponse::AlarmsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__AlarmsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__AlarmsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AlarmsResponse * SOAP_FMAC4 soap_in__ns1__AlarmsResponse(struct soap *soap, const char *tag, _ns1__AlarmsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AlarmsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__AlarmsResponse, sizeof(_ns1__AlarmsResponse), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__AlarmsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__AlarmsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AlarmsResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AlarmsResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:AlarmsResult", (char**)&a->_ns1__AlarmsResponse::AlarmsResult, "xsd:string"))
				{	soap_flag_AlarmsResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:AlarmsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AlarmsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__AlarmsResponse, SOAP_TYPE_protocolv2__ns1__AlarmsResponse, sizeof(_ns1__AlarmsResponse), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__AlarmsResponse * SOAP_FMAC2 soap_instantiate__ns1__AlarmsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AlarmsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__AlarmsResponse *p;
	size_t k = sizeof(_ns1__AlarmsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__AlarmsResponse, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__AlarmsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__AlarmsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__AlarmsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__AlarmsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__AlarmsResponse(soap, tag ? tag : "ns1:AlarmsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AlarmsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AlarmsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AlarmsResponse * SOAP_FMAC4 soap_get__ns1__AlarmsResponse(struct soap *soap, _ns1__AlarmsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AlarmsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Alarms::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _ns1__Alarms::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__Alarms::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Alarms(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Alarms(struct soap *soap, const char *tag, int id, const _ns1__Alarms *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__Alarms), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Alarms::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__Alarms(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Alarms * SOAP_FMAC4 soap_in__ns1__Alarms(struct soap *soap, const char *tag, _ns1__Alarms *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Alarms*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__Alarms, sizeof(_ns1__Alarms), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__Alarms)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__Alarms *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Alarms *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__Alarms, SOAP_TYPE_protocolv2__ns1__Alarms, sizeof(_ns1__Alarms), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Alarms * SOAP_FMAC2 soap_instantiate__ns1__Alarms(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Alarms(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Alarms *p;
	size_t k = sizeof(_ns1__Alarms);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__Alarms, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__Alarms);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__Alarms, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Alarms location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__Alarms::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__Alarms(soap, tag ? tag : "ns1:Alarms", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Alarms::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Alarms(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Alarms * SOAP_FMAC4 soap_get__ns1__Alarms(struct soap *soap, _ns1__Alarms *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Alarms(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__MeasuresResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__MeasuresResponse::MeasuresResult);
}

void _ns1__MeasuresResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__MeasuresResponse::MeasuresResult);
#endif
}

int _ns1__MeasuresResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__MeasuresResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__MeasuresResponse(struct soap *soap, const char *tag, int id, const _ns1__MeasuresResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__MeasuresResponse), type))
		return soap->error;
	if (a->MeasuresResult)
		soap_element_result(soap, "ns1:MeasuresResult");
	if (soap_out_string(soap, "ns1:MeasuresResult", -1, (char*const*)&a->_ns1__MeasuresResponse::MeasuresResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__MeasuresResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__MeasuresResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__MeasuresResponse * SOAP_FMAC4 soap_in__ns1__MeasuresResponse(struct soap *soap, const char *tag, _ns1__MeasuresResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__MeasuresResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__MeasuresResponse, sizeof(_ns1__MeasuresResponse), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__MeasuresResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__MeasuresResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MeasuresResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MeasuresResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:MeasuresResult", (char**)&a->_ns1__MeasuresResponse::MeasuresResult, "xsd:string"))
				{	soap_flag_MeasuresResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:MeasuresResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__MeasuresResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__MeasuresResponse, SOAP_TYPE_protocolv2__ns1__MeasuresResponse, sizeof(_ns1__MeasuresResponse), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__MeasuresResponse * SOAP_FMAC2 soap_instantiate__ns1__MeasuresResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__MeasuresResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__MeasuresResponse *p;
	size_t k = sizeof(_ns1__MeasuresResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__MeasuresResponse, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__MeasuresResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__MeasuresResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__MeasuresResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__MeasuresResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__MeasuresResponse(soap, tag ? tag : "ns1:MeasuresResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__MeasuresResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__MeasuresResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__MeasuresResponse * SOAP_FMAC4 soap_get__ns1__MeasuresResponse(struct soap *soap, _ns1__MeasuresResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__MeasuresResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Measures::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _ns1__Measures::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__Measures::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Measures(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Measures(struct soap *soap, const char *tag, int id, const _ns1__Measures *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__Measures), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Measures::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__Measures(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Measures * SOAP_FMAC4 soap_in__ns1__Measures(struct soap *soap, const char *tag, _ns1__Measures *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Measures*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__Measures, sizeof(_ns1__Measures), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__Measures)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__Measures *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Measures *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__Measures, SOAP_TYPE_protocolv2__ns1__Measures, sizeof(_ns1__Measures), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Measures * SOAP_FMAC2 soap_instantiate__ns1__Measures(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Measures(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Measures *p;
	size_t k = sizeof(_ns1__Measures);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__Measures, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__Measures);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__Measures, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Measures location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__Measures::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__Measures(soap, tag ? tag : "ns1:Measures", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Measures::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Measures(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Measures * SOAP_FMAC4 soap_get__ns1__Measures(struct soap *soap, _ns1__Measures *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Measures(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ReadenMoldsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__ReadenMoldsResponse::ReadenMoldsResult);
}

void _ns1__ReadenMoldsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__ReadenMoldsResponse::ReadenMoldsResult);
#endif
}

int _ns1__ReadenMoldsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ReadenMoldsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ReadenMoldsResponse(struct soap *soap, const char *tag, int id, const _ns1__ReadenMoldsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__ReadenMoldsResponse), type))
		return soap->error;
	if (a->ReadenMoldsResult)
		soap_element_result(soap, "ns1:ReadenMoldsResult");
	if (soap_out_string(soap, "ns1:ReadenMoldsResult", -1, (char*const*)&a->_ns1__ReadenMoldsResponse::ReadenMoldsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ReadenMoldsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__ReadenMoldsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ReadenMoldsResponse * SOAP_FMAC4 soap_in__ns1__ReadenMoldsResponse(struct soap *soap, const char *tag, _ns1__ReadenMoldsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ReadenMoldsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__ReadenMoldsResponse, sizeof(_ns1__ReadenMoldsResponse), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__ReadenMoldsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ReadenMoldsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ReadenMoldsResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ReadenMoldsResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:ReadenMoldsResult", (char**)&a->_ns1__ReadenMoldsResponse::ReadenMoldsResult, "xsd:string"))
				{	soap_flag_ReadenMoldsResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:ReadenMoldsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ReadenMoldsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__ReadenMoldsResponse, SOAP_TYPE_protocolv2__ns1__ReadenMoldsResponse, sizeof(_ns1__ReadenMoldsResponse), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ReadenMoldsResponse * SOAP_FMAC2 soap_instantiate__ns1__ReadenMoldsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ReadenMoldsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ReadenMoldsResponse *p;
	size_t k = sizeof(_ns1__ReadenMoldsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__ReadenMoldsResponse, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ReadenMoldsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ReadenMoldsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ReadenMoldsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ReadenMoldsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ReadenMoldsResponse(soap, tag ? tag : "ns1:ReadenMoldsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ReadenMoldsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ReadenMoldsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ReadenMoldsResponse * SOAP_FMAC4 soap_get__ns1__ReadenMoldsResponse(struct soap *soap, _ns1__ReadenMoldsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ReadenMoldsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ReadenMolds::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _ns1__ReadenMolds::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__ReadenMolds::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ReadenMolds(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ReadenMolds(struct soap *soap, const char *tag, int id, const _ns1__ReadenMolds *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__ReadenMolds), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ReadenMolds::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__ReadenMolds(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ReadenMolds * SOAP_FMAC4 soap_in__ns1__ReadenMolds(struct soap *soap, const char *tag, _ns1__ReadenMolds *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ReadenMolds*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__ReadenMolds, sizeof(_ns1__ReadenMolds), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__ReadenMolds)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ReadenMolds *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ReadenMolds *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__ReadenMolds, SOAP_TYPE_protocolv2__ns1__ReadenMolds, sizeof(_ns1__ReadenMolds), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ReadenMolds * SOAP_FMAC2 soap_instantiate__ns1__ReadenMolds(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ReadenMolds(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ReadenMolds *p;
	size_t k = sizeof(_ns1__ReadenMolds);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__ReadenMolds, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ReadenMolds);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ReadenMolds, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ReadenMolds location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ReadenMolds::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ReadenMolds(soap, tag ? tag : "ns1:ReadenMolds", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ReadenMolds::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ReadenMolds(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ReadenMolds * SOAP_FMAC4 soap_get__ns1__ReadenMolds(struct soap *soap, _ns1__ReadenMolds *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ReadenMolds(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__EjectedMoldsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__EjectedMoldsResponse::EjectedMoldsResult);
}

void _ns1__EjectedMoldsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__EjectedMoldsResponse::EjectedMoldsResult);
#endif
}

int _ns1__EjectedMoldsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__EjectedMoldsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__EjectedMoldsResponse(struct soap *soap, const char *tag, int id, const _ns1__EjectedMoldsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__EjectedMoldsResponse), type))
		return soap->error;
	if (a->EjectedMoldsResult)
		soap_element_result(soap, "ns1:EjectedMoldsResult");
	if (soap_out_string(soap, "ns1:EjectedMoldsResult", -1, (char*const*)&a->_ns1__EjectedMoldsResponse::EjectedMoldsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__EjectedMoldsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__EjectedMoldsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__EjectedMoldsResponse * SOAP_FMAC4 soap_in__ns1__EjectedMoldsResponse(struct soap *soap, const char *tag, _ns1__EjectedMoldsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__EjectedMoldsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__EjectedMoldsResponse, sizeof(_ns1__EjectedMoldsResponse), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__EjectedMoldsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__EjectedMoldsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_EjectedMoldsResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EjectedMoldsResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:EjectedMoldsResult", (char**)&a->_ns1__EjectedMoldsResponse::EjectedMoldsResult, "xsd:string"))
				{	soap_flag_EjectedMoldsResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:EjectedMoldsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__EjectedMoldsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__EjectedMoldsResponse, SOAP_TYPE_protocolv2__ns1__EjectedMoldsResponse, sizeof(_ns1__EjectedMoldsResponse), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__EjectedMoldsResponse * SOAP_FMAC2 soap_instantiate__ns1__EjectedMoldsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__EjectedMoldsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__EjectedMoldsResponse *p;
	size_t k = sizeof(_ns1__EjectedMoldsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__EjectedMoldsResponse, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__EjectedMoldsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__EjectedMoldsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__EjectedMoldsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__EjectedMoldsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__EjectedMoldsResponse(soap, tag ? tag : "ns1:EjectedMoldsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__EjectedMoldsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__EjectedMoldsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__EjectedMoldsResponse * SOAP_FMAC4 soap_get__ns1__EjectedMoldsResponse(struct soap *soap, _ns1__EjectedMoldsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__EjectedMoldsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__EjectedMolds::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _ns1__EjectedMolds::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__EjectedMolds::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__EjectedMolds(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__EjectedMolds(struct soap *soap, const char *tag, int id, const _ns1__EjectedMolds *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__EjectedMolds), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__EjectedMolds::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__EjectedMolds(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__EjectedMolds * SOAP_FMAC4 soap_in__ns1__EjectedMolds(struct soap *soap, const char *tag, _ns1__EjectedMolds *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__EjectedMolds*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__EjectedMolds, sizeof(_ns1__EjectedMolds), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__EjectedMolds)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__EjectedMolds *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__EjectedMolds *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__EjectedMolds, SOAP_TYPE_protocolv2__ns1__EjectedMolds, sizeof(_ns1__EjectedMolds), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__EjectedMolds * SOAP_FMAC2 soap_instantiate__ns1__EjectedMolds(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__EjectedMolds(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__EjectedMolds *p;
	size_t k = sizeof(_ns1__EjectedMolds);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__EjectedMolds, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__EjectedMolds);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__EjectedMolds, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__EjectedMolds location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__EjectedMolds::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__EjectedMolds(soap, tag ? tag : "ns1:EjectedMolds", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__EjectedMolds::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__EjectedMolds(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__EjectedMolds * SOAP_FMAC4 soap_get__ns1__EjectedMolds(struct soap *soap, _ns1__EjectedMolds *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__EjectedMolds(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__MountedMoldsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__MountedMoldsResponse::MountedMoldsResult);
}

void _ns1__MountedMoldsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__MountedMoldsResponse::MountedMoldsResult);
#endif
}

int _ns1__MountedMoldsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__MountedMoldsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__MountedMoldsResponse(struct soap *soap, const char *tag, int id, const _ns1__MountedMoldsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__MountedMoldsResponse), type))
		return soap->error;
	if (a->MountedMoldsResult)
		soap_element_result(soap, "ns1:MountedMoldsResult");
	if (soap_out_string(soap, "ns1:MountedMoldsResult", -1, (char*const*)&a->_ns1__MountedMoldsResponse::MountedMoldsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__MountedMoldsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__MountedMoldsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__MountedMoldsResponse * SOAP_FMAC4 soap_in__ns1__MountedMoldsResponse(struct soap *soap, const char *tag, _ns1__MountedMoldsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__MountedMoldsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__MountedMoldsResponse, sizeof(_ns1__MountedMoldsResponse), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__MountedMoldsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__MountedMoldsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MountedMoldsResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MountedMoldsResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:MountedMoldsResult", (char**)&a->_ns1__MountedMoldsResponse::MountedMoldsResult, "xsd:string"))
				{	soap_flag_MountedMoldsResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:MountedMoldsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__MountedMoldsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__MountedMoldsResponse, SOAP_TYPE_protocolv2__ns1__MountedMoldsResponse, sizeof(_ns1__MountedMoldsResponse), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__MountedMoldsResponse * SOAP_FMAC2 soap_instantiate__ns1__MountedMoldsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__MountedMoldsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__MountedMoldsResponse *p;
	size_t k = sizeof(_ns1__MountedMoldsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__MountedMoldsResponse, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__MountedMoldsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__MountedMoldsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__MountedMoldsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__MountedMoldsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__MountedMoldsResponse(soap, tag ? tag : "ns1:MountedMoldsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__MountedMoldsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__MountedMoldsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__MountedMoldsResponse * SOAP_FMAC4 soap_get__ns1__MountedMoldsResponse(struct soap *soap, _ns1__MountedMoldsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__MountedMoldsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__MountedMolds::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _ns1__MountedMolds::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__MountedMolds::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__MountedMolds(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__MountedMolds(struct soap *soap, const char *tag, int id, const _ns1__MountedMolds *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__MountedMolds), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__MountedMolds::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__MountedMolds(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__MountedMolds * SOAP_FMAC4 soap_in__ns1__MountedMolds(struct soap *soap, const char *tag, _ns1__MountedMolds *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__MountedMolds*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__MountedMolds, sizeof(_ns1__MountedMolds), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__MountedMolds)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__MountedMolds *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__MountedMolds *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__MountedMolds, SOAP_TYPE_protocolv2__ns1__MountedMolds, sizeof(_ns1__MountedMolds), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__MountedMolds * SOAP_FMAC2 soap_instantiate__ns1__MountedMolds(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__MountedMolds(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__MountedMolds *p;
	size_t k = sizeof(_ns1__MountedMolds);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__MountedMolds, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__MountedMolds);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__MountedMolds, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__MountedMolds location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__MountedMolds::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__MountedMolds(soap, tag ? tag : "ns1:MountedMolds", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__MountedMolds::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__MountedMolds(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__MountedMolds * SOAP_FMAC4 soap_get__ns1__MountedMolds(struct soap *soap, _ns1__MountedMolds *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__MountedMolds(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetUpdatedLastRequestDateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_dateTime(soap, &this->_ns1__GetUpdatedLastRequestDateResponse::GetUpdatedLastRequestDateResult);
}

void _ns1__GetUpdatedLastRequestDateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetUpdatedLastRequestDateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetUpdatedLastRequestDateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetUpdatedLastRequestDateResponse(struct soap *soap, const char *tag, int id, const _ns1__GetUpdatedLastRequestDateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDateResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:GetUpdatedLastRequestDateResult");
	if (soap_out_dateTime(soap, "ns1:GetUpdatedLastRequestDateResult", -1, &a->_ns1__GetUpdatedLastRequestDateResponse::GetUpdatedLastRequestDateResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetUpdatedLastRequestDateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__GetUpdatedLastRequestDateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetUpdatedLastRequestDateResponse * SOAP_FMAC4 soap_in__ns1__GetUpdatedLastRequestDateResponse(struct soap *soap, const char *tag, _ns1__GetUpdatedLastRequestDateResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetUpdatedLastRequestDateResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDateResponse, sizeof(_ns1__GetUpdatedLastRequestDateResponse), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDateResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetUpdatedLastRequestDateResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetUpdatedLastRequestDateResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetUpdatedLastRequestDateResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:GetUpdatedLastRequestDateResult", &a->_ns1__GetUpdatedLastRequestDateResponse::GetUpdatedLastRequestDateResult, "xsd:dateTime"))
				{	soap_flag_GetUpdatedLastRequestDateResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetUpdatedLastRequestDateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetUpdatedLastRequestDateResult1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetUpdatedLastRequestDateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDateResponse, SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDateResponse, sizeof(_ns1__GetUpdatedLastRequestDateResponse), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetUpdatedLastRequestDateResponse * SOAP_FMAC2 soap_instantiate__ns1__GetUpdatedLastRequestDateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetUpdatedLastRequestDateResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetUpdatedLastRequestDateResponse *p;
	size_t k = sizeof(_ns1__GetUpdatedLastRequestDateResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDateResponse, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetUpdatedLastRequestDateResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetUpdatedLastRequestDateResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetUpdatedLastRequestDateResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetUpdatedLastRequestDateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetUpdatedLastRequestDateResponse(soap, tag ? tag : "ns1:GetUpdatedLastRequestDateResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetUpdatedLastRequestDateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetUpdatedLastRequestDateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetUpdatedLastRequestDateResponse * SOAP_FMAC4 soap_get__ns1__GetUpdatedLastRequestDateResponse(struct soap *soap, _ns1__GetUpdatedLastRequestDateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetUpdatedLastRequestDateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetUpdatedLastRequestDate::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetUpdatedLastRequestDate::functionNumber);
}

void _ns1__GetUpdatedLastRequestDate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__GetUpdatedLastRequestDate::functionNumber, SOAP_TYPE_protocolv2_int);
#endif
}

int _ns1__GetUpdatedLastRequestDate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetUpdatedLastRequestDate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetUpdatedLastRequestDate(struct soap *soap, const char *tag, int id, const _ns1__GetUpdatedLastRequestDate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDate), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:functionNumber", -1, &a->_ns1__GetUpdatedLastRequestDate::functionNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetUpdatedLastRequestDate::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__GetUpdatedLastRequestDate(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetUpdatedLastRequestDate * SOAP_FMAC4 soap_in__ns1__GetUpdatedLastRequestDate(struct soap *soap, const char *tag, _ns1__GetUpdatedLastRequestDate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetUpdatedLastRequestDate*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDate, sizeof(_ns1__GetUpdatedLastRequestDate), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDate)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetUpdatedLastRequestDate *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_functionNumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_functionNumber1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:functionNumber", &a->_ns1__GetUpdatedLastRequestDate::functionNumber, "xsd:int"))
				{	soap_flag_functionNumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_functionNumber1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetUpdatedLastRequestDate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDate, SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDate, sizeof(_ns1__GetUpdatedLastRequestDate), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetUpdatedLastRequestDate * SOAP_FMAC2 soap_instantiate__ns1__GetUpdatedLastRequestDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetUpdatedLastRequestDate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetUpdatedLastRequestDate *p;
	size_t k = sizeof(_ns1__GetUpdatedLastRequestDate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDate, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetUpdatedLastRequestDate);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetUpdatedLastRequestDate, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetUpdatedLastRequestDate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetUpdatedLastRequestDate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetUpdatedLastRequestDate(soap, tag ? tag : "ns1:GetUpdatedLastRequestDate", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetUpdatedLastRequestDate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetUpdatedLastRequestDate(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetUpdatedLastRequestDate * SOAP_FMAC4 soap_get__ns1__GetUpdatedLastRequestDate(struct soap *soap, _ns1__GetUpdatedLastRequestDate *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetUpdatedLastRequestDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__PreserveCountsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__PreserveCountsResponse::PreserveCountsResult);
}

void _ns1__PreserveCountsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__PreserveCountsResponse::PreserveCountsResult);
#endif
}

int _ns1__PreserveCountsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PreserveCountsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PreserveCountsResponse(struct soap *soap, const char *tag, int id, const _ns1__PreserveCountsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__PreserveCountsResponse), type))
		return soap->error;
	if (a->PreserveCountsResult)
		soap_element_result(soap, "ns1:PreserveCountsResult");
	if (soap_out_string(soap, "ns1:PreserveCountsResult", -1, (char*const*)&a->_ns1__PreserveCountsResponse::PreserveCountsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__PreserveCountsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__PreserveCountsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PreserveCountsResponse * SOAP_FMAC4 soap_in__ns1__PreserveCountsResponse(struct soap *soap, const char *tag, _ns1__PreserveCountsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PreserveCountsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__PreserveCountsResponse, sizeof(_ns1__PreserveCountsResponse), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__PreserveCountsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__PreserveCountsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PreserveCountsResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PreserveCountsResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:PreserveCountsResult", (char**)&a->_ns1__PreserveCountsResponse::PreserveCountsResult, "xsd:string"))
				{	soap_flag_PreserveCountsResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:PreserveCountsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PreserveCountsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__PreserveCountsResponse, SOAP_TYPE_protocolv2__ns1__PreserveCountsResponse, sizeof(_ns1__PreserveCountsResponse), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__PreserveCountsResponse * SOAP_FMAC2 soap_instantiate__ns1__PreserveCountsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PreserveCountsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__PreserveCountsResponse *p;
	size_t k = sizeof(_ns1__PreserveCountsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__PreserveCountsResponse, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__PreserveCountsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__PreserveCountsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__PreserveCountsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__PreserveCountsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__PreserveCountsResponse(soap, tag ? tag : "ns1:PreserveCountsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PreserveCountsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PreserveCountsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PreserveCountsResponse * SOAP_FMAC4 soap_get__ns1__PreserveCountsResponse(struct soap *soap, _ns1__PreserveCountsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PreserveCountsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__PreserveCounts::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _ns1__PreserveCounts::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__PreserveCounts::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PreserveCounts(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PreserveCounts(struct soap *soap, const char *tag, int id, const _ns1__PreserveCounts *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__PreserveCounts), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__PreserveCounts::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__PreserveCounts(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PreserveCounts * SOAP_FMAC4 soap_in__ns1__PreserveCounts(struct soap *soap, const char *tag, _ns1__PreserveCounts *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PreserveCounts*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__PreserveCounts, sizeof(_ns1__PreserveCounts), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__PreserveCounts)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__PreserveCounts *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PreserveCounts *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__PreserveCounts, SOAP_TYPE_protocolv2__ns1__PreserveCounts, sizeof(_ns1__PreserveCounts), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__PreserveCounts * SOAP_FMAC2 soap_instantiate__ns1__PreserveCounts(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PreserveCounts(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__PreserveCounts *p;
	size_t k = sizeof(_ns1__PreserveCounts);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__PreserveCounts, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__PreserveCounts);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__PreserveCounts, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__PreserveCounts location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__PreserveCounts::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__PreserveCounts(soap, tag ? tag : "ns1:PreserveCounts", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PreserveCounts::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PreserveCounts(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PreserveCounts * SOAP_FMAC4 soap_get__ns1__PreserveCounts(struct soap *soap, _ns1__PreserveCounts *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PreserveCounts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CountsByArticleResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CountsByArticleResponse::CountsByArticleResult = NULL;
}

void _ns1__CountsByArticleResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__CountsByArticleResult(soap, &this->_ns1__CountsByArticleResponse::CountsByArticleResult);
#endif
}

int _ns1__CountsByArticleResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CountsByArticleResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CountsByArticleResponse(struct soap *soap, const char *tag, int id, const _ns1__CountsByArticleResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__CountsByArticleResponse), type))
		return soap->error;
	if (a->CountsByArticleResult)
		soap_element_result(soap, "ns1:CountsByArticleResult");
	if (soap_out_PointerTons1__CountsByArticleResult(soap, "ns1:CountsByArticleResult", -1, &a->_ns1__CountsByArticleResponse::CountsByArticleResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CountsByArticleResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__CountsByArticleResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CountsByArticleResponse * SOAP_FMAC4 soap_in__ns1__CountsByArticleResponse(struct soap *soap, const char *tag, _ns1__CountsByArticleResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CountsByArticleResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__CountsByArticleResponse, sizeof(_ns1__CountsByArticleResponse), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__CountsByArticleResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CountsByArticleResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CountsByArticleResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CountsByArticleResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CountsByArticleResult(soap, "ns1:CountsByArticleResult", &a->_ns1__CountsByArticleResponse::CountsByArticleResult, "ns1:CountsByArticleResult"))
				{	soap_flag_CountsByArticleResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:CountsByArticleResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CountsByArticleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__CountsByArticleResponse, SOAP_TYPE_protocolv2__ns1__CountsByArticleResponse, sizeof(_ns1__CountsByArticleResponse), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CountsByArticleResponse * SOAP_FMAC2 soap_instantiate__ns1__CountsByArticleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CountsByArticleResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CountsByArticleResponse *p;
	size_t k = sizeof(_ns1__CountsByArticleResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__CountsByArticleResponse, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__CountsByArticleResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__CountsByArticleResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CountsByArticleResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__CountsByArticleResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CountsByArticleResponse(soap, tag ? tag : "ns1:CountsByArticleResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CountsByArticleResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CountsByArticleResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CountsByArticleResponse * SOAP_FMAC4 soap_get__ns1__CountsByArticleResponse(struct soap *soap, _ns1__CountsByArticleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CountsByArticleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CountsByArticle::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _ns1__CountsByArticle::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__CountsByArticle::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CountsByArticle(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CountsByArticle(struct soap *soap, const char *tag, int id, const _ns1__CountsByArticle *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__CountsByArticle), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CountsByArticle::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__CountsByArticle(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CountsByArticle * SOAP_FMAC4 soap_in__ns1__CountsByArticle(struct soap *soap, const char *tag, _ns1__CountsByArticle *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CountsByArticle*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__CountsByArticle, sizeof(_ns1__CountsByArticle), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__CountsByArticle)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CountsByArticle *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CountsByArticle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__CountsByArticle, SOAP_TYPE_protocolv2__ns1__CountsByArticle, sizeof(_ns1__CountsByArticle), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CountsByArticle * SOAP_FMAC2 soap_instantiate__ns1__CountsByArticle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CountsByArticle(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CountsByArticle *p;
	size_t k = sizeof(_ns1__CountsByArticle);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__CountsByArticle, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__CountsByArticle);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__CountsByArticle, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CountsByArticle location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__CountsByArticle::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CountsByArticle(soap, tag ? tag : "ns1:CountsByArticle", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CountsByArticle::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CountsByArticle(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CountsByArticle * SOAP_FMAC4 soap_get__ns1__CountsByArticle(struct soap *soap, _ns1__CountsByArticle *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CountsByArticle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CountsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__CountsResponse::CountsResult);
}

void _ns1__CountsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__CountsResponse::CountsResult);
#endif
}

int _ns1__CountsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CountsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CountsResponse(struct soap *soap, const char *tag, int id, const _ns1__CountsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__CountsResponse), type))
		return soap->error;
	if (a->CountsResult)
		soap_element_result(soap, "ns1:CountsResult");
	if (soap_out_string(soap, "ns1:CountsResult", -1, (char*const*)&a->_ns1__CountsResponse::CountsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CountsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__CountsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CountsResponse * SOAP_FMAC4 soap_in__ns1__CountsResponse(struct soap *soap, const char *tag, _ns1__CountsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CountsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__CountsResponse, sizeof(_ns1__CountsResponse), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__CountsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CountsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CountsResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CountsResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:CountsResult", (char**)&a->_ns1__CountsResponse::CountsResult, "xsd:string"))
				{	soap_flag_CountsResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:CountsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CountsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__CountsResponse, SOAP_TYPE_protocolv2__ns1__CountsResponse, sizeof(_ns1__CountsResponse), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CountsResponse * SOAP_FMAC2 soap_instantiate__ns1__CountsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CountsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CountsResponse *p;
	size_t k = sizeof(_ns1__CountsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__CountsResponse, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__CountsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__CountsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CountsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__CountsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CountsResponse(soap, tag ? tag : "ns1:CountsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CountsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CountsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CountsResponse * SOAP_FMAC4 soap_get__ns1__CountsResponse(struct soap *soap, _ns1__CountsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CountsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Counts::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _ns1__Counts::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__Counts::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Counts(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Counts(struct soap *soap, const char *tag, int id, const _ns1__Counts *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2__ns1__Counts), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Counts::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__Counts(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Counts * SOAP_FMAC4 soap_in__ns1__Counts(struct soap *soap, const char *tag, _ns1__Counts *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Counts*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2__ns1__Counts, sizeof(_ns1__Counts), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2__ns1__Counts)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__Counts *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Counts *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2__ns1__Counts, SOAP_TYPE_protocolv2__ns1__Counts, sizeof(_ns1__Counts), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Counts * SOAP_FMAC2 soap_instantiate__ns1__Counts(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Counts(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Counts *p;
	size_t k = sizeof(_ns1__Counts);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2__ns1__Counts, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__Counts);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__Counts, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Counts location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__Counts::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__Counts(soap, tag ? tag : "ns1:Counts", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Counts::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Counts(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Counts * SOAP_FMAC4 soap_get__ns1__Counts(struct soap *soap, _ns1__Counts *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Counts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfCCompteurArticle::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfCCompteurArticle::__sizeArticle = 0;
	this->ns1__ArrayOfCCompteurArticle::Article = NULL;
}

void ns1__ArrayOfCCompteurArticle::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->ns1__ArrayOfCCompteurArticle::Article)
	{	int i;
		for (i = 0; i < (int)this->ns1__ArrayOfCCompteurArticle::__sizeArticle; i++)
		{
			soap_serialize_PointerTons1__CCompteurArticle(soap, this->ns1__ArrayOfCCompteurArticle::Article + i);
		}
	}
#endif
}

int ns1__ArrayOfCCompteurArticle::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfCCompteurArticle(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfCCompteurArticle(struct soap *soap, const char *tag, int id, const ns1__ArrayOfCCompteurArticle *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2_ns1__ArrayOfCCompteurArticle), type))
		return soap->error;
	if (a->ns1__ArrayOfCCompteurArticle::Article)
	{	int i;
		for (i = 0; i < (int)a->ns1__ArrayOfCCompteurArticle::__sizeArticle; i++)
			if (soap_out_PointerTons1__CCompteurArticle(soap, "ns1:Article", -1, a->ns1__ArrayOfCCompteurArticle::Article + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfCCompteurArticle::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ArrayOfCCompteurArticle(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfCCompteurArticle * SOAP_FMAC4 soap_in_ns1__ArrayOfCCompteurArticle(struct soap *soap, const char *tag, ns1__ArrayOfCCompteurArticle *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfCCompteurArticle*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2_ns1__ArrayOfCCompteurArticle, sizeof(ns1__ArrayOfCCompteurArticle), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2_ns1__ArrayOfCCompteurArticle)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ArrayOfCCompteurArticle *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	struct soap_blist *soap_blist_Article1 = NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Article", 1, NULL))
			{	if (a->ns1__ArrayOfCCompteurArticle::Article == NULL)
				{	if (soap_blist_Article1 == NULL)
						soap_blist_Article1 = soap_alloc_block(soap);
					a->ns1__ArrayOfCCompteurArticle::Article = (ns1__CCompteurArticle **)soap_push_block_max(soap, soap_blist_Article1, sizeof(ns1__CCompteurArticle *));
					if (a->ns1__ArrayOfCCompteurArticle::Article == NULL)
						return NULL;
					*a->ns1__ArrayOfCCompteurArticle::Article = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__CCompteurArticle(soap, "ns1:Article", a->ns1__ArrayOfCCompteurArticle::Article, "ns1:CCompteurArticle"))
				{	a->ns1__ArrayOfCCompteurArticle::__sizeArticle++;
					a->ns1__ArrayOfCCompteurArticle::Article = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfCCompteurArticle::Article)
			soap_pop_block(soap, soap_blist_Article1);
		if (a->ns1__ArrayOfCCompteurArticle::__sizeArticle)
		{	a->ns1__ArrayOfCCompteurArticle::Article = (ns1__CCompteurArticle **)soap_save_block(soap, soap_blist_Article1, NULL, 1);
		}
		else
		{	a->ns1__ArrayOfCCompteurArticle::Article = NULL;
			if (soap_blist_Article1)
				soap_end_block(soap, soap_blist_Article1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfCCompteurArticle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2_ns1__ArrayOfCCompteurArticle, SOAP_TYPE_protocolv2_ns1__ArrayOfCCompteurArticle, sizeof(ns1__ArrayOfCCompteurArticle), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfCCompteurArticle * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfCCompteurArticle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfCCompteurArticle(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfCCompteurArticle *p;
	size_t k = sizeof(ns1__ArrayOfCCompteurArticle);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2_ns1__ArrayOfCCompteurArticle, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ArrayOfCCompteurArticle);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ArrayOfCCompteurArticle, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfCCompteurArticle location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ArrayOfCCompteurArticle::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ArrayOfCCompteurArticle(soap, tag ? tag : "ns1:ArrayOfCCompteurArticle", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfCCompteurArticle::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfCCompteurArticle(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfCCompteurArticle * SOAP_FMAC4 soap_get_ns1__ArrayOfCCompteurArticle(struct soap *soap, ns1__ArrayOfCCompteurArticle *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfCCompteurArticle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__CCompteurArticle::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__CCompteurMoule::soap_default(soap);
	this->ns1__CCompteurArticle::__sizeSensor = 0;
	this->ns1__CCompteurArticle::Sensor = NULL;
	soap_default_int(soap, &this->ns1__CCompteurArticle::id);
}

void ns1__CCompteurArticle::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->ns1__CCompteurArticle::Sensor)
	{	int i;
		for (i = 0; i < (int)this->ns1__CCompteurArticle::__sizeSensor; i++)
		{
			soap_serialize_PointerTons1__CCompteurMouleCapteur(soap, this->ns1__CCompteurArticle::Sensor + i);
		}
	}
	this->ns1__CCompteurMoule::soap_serialize(soap);
#endif
}

int ns1__CCompteurArticle::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CCompteurArticle(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CCompteurArticle(struct soap *soap, const char *tag, int id, const ns1__CCompteurArticle *a, const char *type)
{
	soap_set_attr(soap, "id", soap_int2s(soap, ((ns1__CCompteurArticle*)a)->id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2_ns1__CCompteurArticle), type ? type : "ns1:CCompteurArticle"))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:Inspected", -1, &a->ns1__CCompteurMoule::Inspected, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:Rejects", -1, &a->ns1__CCompteurMoule::Rejects, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:Defects", -1, &a->ns1__CCompteurMoule::Defects, ""))
		return soap->error;
	if (a->ns1__CCompteurArticle::Sensor)
	{	int i;
		for (i = 0; i < (int)a->ns1__CCompteurArticle::__sizeSensor; i++)
			if (soap_out_PointerTons1__CCompteurMouleCapteur(soap, "ns1:Sensor", -1, a->ns1__CCompteurArticle::Sensor + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__CCompteurArticle::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__CCompteurArticle(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CCompteurArticle * SOAP_FMAC4 soap_in_ns1__CCompteurArticle(struct soap *soap, const char *tag, ns1__CCompteurArticle *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CCompteurArticle*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2_ns1__CCompteurArticle, sizeof(ns1__CCompteurArticle), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2_ns1__CCompteurArticle)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__CCompteurArticle *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2int(soap, soap_attr_value(soap, "id", 5, 1), &((ns1__CCompteurArticle*)a)->id))
		return NULL;
	size_t soap_flag_Inspected2 = 1;
	size_t soap_flag_Rejects2 = 1;
	size_t soap_flag_Defects2 = 1;
	struct soap_blist *soap_blist_Sensor1 = NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Inspected2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:Inspected", &a->ns1__CCompteurMoule::Inspected, "xsd:int"))
				{	soap_flag_Inspected2--;
					continue;
				}
			}
			if (soap_flag_Rejects2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:Rejects", &a->ns1__CCompteurMoule::Rejects, "xsd:int"))
				{	soap_flag_Rejects2--;
					continue;
				}
			}
			if (soap_flag_Defects2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:Defects", &a->ns1__CCompteurMoule::Defects, "xsd:int"))
				{	soap_flag_Defects2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Sensor", 1, NULL))
			{	if (a->ns1__CCompteurArticle::Sensor == NULL)
				{	if (soap_blist_Sensor1 == NULL)
						soap_blist_Sensor1 = soap_alloc_block(soap);
					a->ns1__CCompteurArticle::Sensor = (ns1__CCompteurMouleCapteur **)soap_push_block_max(soap, soap_blist_Sensor1, sizeof(ns1__CCompteurMouleCapteur *));
					if (a->ns1__CCompteurArticle::Sensor == NULL)
						return NULL;
					*a->ns1__CCompteurArticle::Sensor = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__CCompteurMouleCapteur(soap, "ns1:Sensor", a->ns1__CCompteurArticle::Sensor, "ns1:CCompteurMouleCapteur"))
				{	a->ns1__CCompteurArticle::__sizeSensor++;
					a->ns1__CCompteurArticle::Sensor = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__CCompteurArticle::Sensor)
			soap_pop_block(soap, soap_blist_Sensor1);
		if (a->ns1__CCompteurArticle::__sizeSensor)
		{	a->ns1__CCompteurArticle::Sensor = (ns1__CCompteurMouleCapteur **)soap_save_block(soap, soap_blist_Sensor1, NULL, 1);
		}
		else
		{	a->ns1__CCompteurArticle::Sensor = NULL;
			if (soap_blist_Sensor1)
				soap_end_block(soap, soap_blist_Sensor1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Rejects2 > 0 || soap_flag_Defects2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__CCompteurArticle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2_ns1__CCompteurArticle, SOAP_TYPE_protocolv2_ns1__CCompteurArticle, sizeof(ns1__CCompteurArticle), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__CCompteurArticle * SOAP_FMAC2 soap_instantiate_ns1__CCompteurArticle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CCompteurArticle(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__CCompteurArticle *p;
	size_t k = sizeof(ns1__CCompteurArticle);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2_ns1__CCompteurArticle, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__CCompteurArticle);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__CCompteurArticle, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__CCompteurArticle location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__CCompteurArticle::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__CCompteurArticle(soap, tag ? tag : "ns1:CCompteurArticle", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CCompteurArticle::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CCompteurArticle(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CCompteurArticle * SOAP_FMAC4 soap_get_ns1__CCompteurArticle(struct soap *soap, ns1__CCompteurArticle *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CCompteurArticle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__CCounter::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__CCounter::id);
	soap_default_int(soap, &this->ns1__CCounter::nb);
}

void ns1__CCounter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__CCounter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CCounter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CCounter(struct soap *soap, const char *tag, int id, const ns1__CCounter *a, const char *type)
{
	soap_set_attr(soap, "id", soap_int2s(soap, ((ns1__CCounter*)a)->id), 1);
	soap_set_attr(soap, "nb", soap_int2s(soap, ((ns1__CCounter*)a)->nb), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2_ns1__CCounter), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CCounter::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__CCounter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CCounter * SOAP_FMAC4 soap_in_ns1__CCounter(struct soap *soap, const char *tag, ns1__CCounter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CCounter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2_ns1__CCounter, sizeof(ns1__CCounter), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2_ns1__CCounter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__CCounter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2int(soap, soap_attr_value(soap, "id", 5, 1), &((ns1__CCounter*)a)->id))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "nb", 5, 1), &((ns1__CCounter*)a)->nb))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CCounter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2_ns1__CCounter, SOAP_TYPE_protocolv2_ns1__CCounter, sizeof(ns1__CCounter), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__CCounter * SOAP_FMAC2 soap_instantiate_ns1__CCounter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CCounter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__CCounter *p;
	size_t k = sizeof(ns1__CCounter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2_ns1__CCounter, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__CCounter);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__CCounter, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__CCounter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__CCounter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__CCounter(soap, tag ? tag : "ns1:CCounter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CCounter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CCounter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CCounter * SOAP_FMAC4 soap_get_ns1__CCounter(struct soap *soap, ns1__CCounter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CCounter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__CCompteurMouleCapteur::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__CCompteurMoule::soap_default(soap);
	this->ns1__CCompteurMouleCapteur::__sizeCounter = 0;
	this->ns1__CCompteurMouleCapteur::Counter = NULL;
	soap_default_int(soap, &this->ns1__CCompteurMouleCapteur::id);
}

void ns1__CCompteurMouleCapteur::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->ns1__CCompteurMouleCapteur::Counter)
	{	int i;
		for (i = 0; i < (int)this->ns1__CCompteurMouleCapteur::__sizeCounter; i++)
		{
			soap_serialize_PointerTons1__CCounter(soap, this->ns1__CCompteurMouleCapteur::Counter + i);
		}
	}
	this->ns1__CCompteurMoule::soap_serialize(soap);
#endif
}

int ns1__CCompteurMouleCapteur::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CCompteurMouleCapteur(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CCompteurMouleCapteur(struct soap *soap, const char *tag, int id, const ns1__CCompteurMouleCapteur *a, const char *type)
{
	soap_set_attr(soap, "id", soap_int2s(soap, ((ns1__CCompteurMouleCapteur*)a)->id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2_ns1__CCompteurMouleCapteur), type ? type : "ns1:CCompteurMouleCapteur"))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:Inspected", -1, &a->ns1__CCompteurMoule::Inspected, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:Rejects", -1, &a->ns1__CCompteurMoule::Rejects, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:Defects", -1, &a->ns1__CCompteurMoule::Defects, ""))
		return soap->error;
	if (a->ns1__CCompteurMouleCapteur::Counter)
	{	int i;
		for (i = 0; i < (int)a->ns1__CCompteurMouleCapteur::__sizeCounter; i++)
			if (soap_out_PointerTons1__CCounter(soap, "ns1:Counter", -1, a->ns1__CCompteurMouleCapteur::Counter + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__CCompteurMouleCapteur::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__CCompteurMouleCapteur(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CCompteurMouleCapteur * SOAP_FMAC4 soap_in_ns1__CCompteurMouleCapteur(struct soap *soap, const char *tag, ns1__CCompteurMouleCapteur *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CCompteurMouleCapteur*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2_ns1__CCompteurMouleCapteur, sizeof(ns1__CCompteurMouleCapteur), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2_ns1__CCompteurMouleCapteur)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__CCompteurMouleCapteur *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2int(soap, soap_attr_value(soap, "id", 5, 1), &((ns1__CCompteurMouleCapteur*)a)->id))
		return NULL;
	size_t soap_flag_Inspected2 = 1;
	size_t soap_flag_Rejects2 = 1;
	size_t soap_flag_Defects2 = 1;
	struct soap_blist *soap_blist_Counter1 = NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Inspected2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:Inspected", &a->ns1__CCompteurMoule::Inspected, "xsd:int"))
				{	soap_flag_Inspected2--;
					continue;
				}
			}
			if (soap_flag_Rejects2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:Rejects", &a->ns1__CCompteurMoule::Rejects, "xsd:int"))
				{	soap_flag_Rejects2--;
					continue;
				}
			}
			if (soap_flag_Defects2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:Defects", &a->ns1__CCompteurMoule::Defects, "xsd:int"))
				{	soap_flag_Defects2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Counter", 1, NULL))
			{	if (a->ns1__CCompteurMouleCapteur::Counter == NULL)
				{	if (soap_blist_Counter1 == NULL)
						soap_blist_Counter1 = soap_alloc_block(soap);
					a->ns1__CCompteurMouleCapteur::Counter = (ns1__CCounter **)soap_push_block_max(soap, soap_blist_Counter1, sizeof(ns1__CCounter *));
					if (a->ns1__CCompteurMouleCapteur::Counter == NULL)
						return NULL;
					*a->ns1__CCompteurMouleCapteur::Counter = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__CCounter(soap, "ns1:Counter", a->ns1__CCompteurMouleCapteur::Counter, "ns1:CCounter"))
				{	a->ns1__CCompteurMouleCapteur::__sizeCounter++;
					a->ns1__CCompteurMouleCapteur::Counter = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__CCompteurMouleCapteur::Counter)
			soap_pop_block(soap, soap_blist_Counter1);
		if (a->ns1__CCompteurMouleCapteur::__sizeCounter)
		{	a->ns1__CCompteurMouleCapteur::Counter = (ns1__CCounter **)soap_save_block(soap, soap_blist_Counter1, NULL, 1);
		}
		else
		{	a->ns1__CCompteurMouleCapteur::Counter = NULL;
			if (soap_blist_Counter1)
				soap_end_block(soap, soap_blist_Counter1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Rejects2 > 0 || soap_flag_Defects2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__CCompteurMouleCapteur *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2_ns1__CCompteurMouleCapteur, SOAP_TYPE_protocolv2_ns1__CCompteurMouleCapteur, sizeof(ns1__CCompteurMouleCapteur), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__CCompteurMouleCapteur * SOAP_FMAC2 soap_instantiate_ns1__CCompteurMouleCapteur(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CCompteurMouleCapteur(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__CCompteurMouleCapteur *p;
	size_t k = sizeof(ns1__CCompteurMouleCapteur);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2_ns1__CCompteurMouleCapteur, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__CCompteurMouleCapteur);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__CCompteurMouleCapteur, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__CCompteurMouleCapteur location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__CCompteurMouleCapteur::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__CCompteurMouleCapteur(soap, tag ? tag : "ns1:CCompteurMouleCapteur", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CCompteurMouleCapteur::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CCompteurMouleCapteur(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CCompteurMouleCapteur * SOAP_FMAC4 soap_get_ns1__CCompteurMouleCapteur(struct soap *soap, ns1__CCompteurMouleCapteur *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CCompteurMouleCapteur(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__CCompteurMoule::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__CCompteurMoule::Inspected = NULL;
	soap_default_int(soap, &this->ns1__CCompteurMoule::Rejects);
	soap_default_int(soap, &this->ns1__CCompteurMoule::Defects);
}

void ns1__CCompteurMoule::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->ns1__CCompteurMoule::Inspected);
	soap_embedded(soap, &this->ns1__CCompteurMoule::Rejects, SOAP_TYPE_protocolv2_int);
	soap_embedded(soap, &this->ns1__CCompteurMoule::Defects, SOAP_TYPE_protocolv2_int);
#endif
}

int ns1__CCompteurMoule::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CCompteurMoule(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CCompteurMoule(struct soap *soap, const char *tag, int id, const ns1__CCompteurMoule *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2_ns1__CCompteurMoule), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:Inspected", -1, &a->ns1__CCompteurMoule::Inspected, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:Rejects", -1, &a->ns1__CCompteurMoule::Rejects, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:Defects", -1, &a->ns1__CCompteurMoule::Defects, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CCompteurMoule::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__CCompteurMoule(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CCompteurMoule * SOAP_FMAC4 soap_in_ns1__CCompteurMoule(struct soap *soap, const char *tag, ns1__CCompteurMoule *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CCompteurMoule*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2_ns1__CCompteurMoule, sizeof(ns1__CCompteurMoule), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2_ns1__CCompteurMoule)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__CCompteurMoule *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Inspected1 = 1;
	size_t soap_flag_Rejects1 = 1;
	size_t soap_flag_Defects1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Inspected1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:Inspected", &a->ns1__CCompteurMoule::Inspected, "xsd:int"))
				{	soap_flag_Inspected1--;
					continue;
				}
			}
			if (soap_flag_Rejects1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:Rejects", &a->ns1__CCompteurMoule::Rejects, "xsd:int"))
				{	soap_flag_Rejects1--;
					continue;
				}
			}
			if (soap_flag_Defects1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:Defects", &a->ns1__CCompteurMoule::Defects, "xsd:int"))
				{	soap_flag_Defects1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Rejects1 > 0 || soap_flag_Defects1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__CCompteurMoule *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2_ns1__CCompteurMoule, SOAP_TYPE_protocolv2_ns1__CCompteurMoule, sizeof(ns1__CCompteurMoule), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__CCompteurMoule * SOAP_FMAC2 soap_instantiate_ns1__CCompteurMoule(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CCompteurMoule(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "ns1:CCompteurMachine"))
		return soap_instantiate_ns1__CCompteurMachine(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:CCompteurMouleCapteur"))
		return soap_instantiate_ns1__CCompteurMouleCapteur(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns1:CCompteurArticle"))
		return soap_instantiate_ns1__CCompteurArticle(soap, n, NULL, NULL, size);
	ns1__CCompteurMoule *p;
	size_t k = sizeof(ns1__CCompteurMoule);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2_ns1__CCompteurMoule, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__CCompteurMoule);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__CCompteurMoule, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__CCompteurMoule location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__CCompteurMoule::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__CCompteurMoule(soap, tag ? tag : "ns1:CCompteurMoule", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CCompteurMoule::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CCompteurMoule(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CCompteurMoule * SOAP_FMAC4 soap_get_ns1__CCompteurMoule(struct soap *soap, ns1__CCompteurMoule *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CCompteurMoule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__CCompteurMachine::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__CCompteurMoule::soap_default(soap);
	soap_default_int(soap, &this->ns1__CCompteurMachine::Identified);
	soap_default_int(soap, &this->ns1__CCompteurMachine::Unidentified);
	this->ns1__CCompteurMachine::Articles = NULL;
	soap_default_string(soap, &this->ns1__CCompteurMachine::Id);
}

void ns1__CCompteurMachine::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__CCompteurMachine::Identified, SOAP_TYPE_protocolv2_int);
	soap_embedded(soap, &this->ns1__CCompteurMachine::Unidentified, SOAP_TYPE_protocolv2_int);
	soap_serialize_PointerTons1__ArrayOfCCompteurArticle(soap, &this->ns1__CCompteurMachine::Articles);
	this->ns1__CCompteurMoule::soap_serialize(soap);
#endif
}

int ns1__CCompteurMachine::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CCompteurMachine(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CCompteurMachine(struct soap *soap, const char *tag, int id, const ns1__CCompteurMachine *a, const char *type)
{
	if (((ns1__CCompteurMachine*)a)->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, ((ns1__CCompteurMachine*)a)->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2_ns1__CCompteurMachine), type ? type : "ns1:CCompteurMachine"))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:Inspected", -1, &a->ns1__CCompteurMoule::Inspected, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:Rejects", -1, &a->ns1__CCompteurMoule::Rejects, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:Defects", -1, &a->ns1__CCompteurMoule::Defects, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:Identified", -1, &a->ns1__CCompteurMachine::Identified, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:Unidentified", -1, &a->ns1__CCompteurMachine::Unidentified, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfCCompteurArticle(soap, "ns1:Articles", -1, &a->ns1__CCompteurMachine::Articles, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CCompteurMachine::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__CCompteurMachine(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CCompteurMachine * SOAP_FMAC4 soap_in_ns1__CCompteurMachine(struct soap *soap, const char *tag, ns1__CCompteurMachine *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CCompteurMachine*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2_ns1__CCompteurMachine, sizeof(ns1__CCompteurMachine), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2_ns1__CCompteurMachine)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__CCompteurMachine *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &((ns1__CCompteurMachine*)a)->Id))
		return NULL;
	size_t soap_flag_Inspected2 = 1;
	size_t soap_flag_Rejects2 = 1;
	size_t soap_flag_Defects2 = 1;
	size_t soap_flag_Identified1 = 1;
	size_t soap_flag_Unidentified1 = 1;
	size_t soap_flag_Articles1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Inspected2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns1:Inspected", &a->ns1__CCompteurMoule::Inspected, "xsd:int"))
				{	soap_flag_Inspected2--;
					continue;
				}
			}
			if (soap_flag_Rejects2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:Rejects", &a->ns1__CCompteurMoule::Rejects, "xsd:int"))
				{	soap_flag_Rejects2--;
					continue;
				}
			}
			if (soap_flag_Defects2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:Defects", &a->ns1__CCompteurMoule::Defects, "xsd:int"))
				{	soap_flag_Defects2--;
					continue;
				}
			}
			if (soap_flag_Identified1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:Identified", &a->ns1__CCompteurMachine::Identified, "xsd:int"))
				{	soap_flag_Identified1--;
					continue;
				}
			}
			if (soap_flag_Unidentified1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:Unidentified", &a->ns1__CCompteurMachine::Unidentified, "xsd:int"))
				{	soap_flag_Unidentified1--;
					continue;
				}
			}
			if (soap_flag_Articles1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfCCompteurArticle(soap, "ns1:Articles", &a->ns1__CCompteurMachine::Articles, "ns1:ArrayOfCCompteurArticle"))
				{	soap_flag_Articles1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Rejects2 > 0 || soap_flag_Defects2 > 0 || soap_flag_Identified1 > 0 || soap_flag_Unidentified1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__CCompteurMachine *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2_ns1__CCompteurMachine, SOAP_TYPE_protocolv2_ns1__CCompteurMachine, sizeof(ns1__CCompteurMachine), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__CCompteurMachine * SOAP_FMAC2 soap_instantiate_ns1__CCompteurMachine(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CCompteurMachine(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__CCompteurMachine *p;
	size_t k = sizeof(ns1__CCompteurMachine);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2_ns1__CCompteurMachine, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__CCompteurMachine);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__CCompteurMachine, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__CCompteurMachine location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__CCompteurMachine::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__CCompteurMachine(soap, tag ? tag : "ns1:CCompteurMachine", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CCompteurMachine::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CCompteurMachine(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CCompteurMachine * SOAP_FMAC4 soap_get_ns1__CCompteurMachine(struct soap *soap, ns1__CCompteurMachine *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CCompteurMachine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__CountsByArticleResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__CountsByArticleResult::Machine = NULL;
}

void ns1__CountsByArticleResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__CCompteurMachine(soap, &this->ns1__CountsByArticleResult::Machine);
#endif
}

int ns1__CountsByArticleResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CountsByArticleResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CountsByArticleResult(struct soap *soap, const char *tag, int id, const ns1__CountsByArticleResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2_ns1__CountsByArticleResult), type))
		return soap->error;
	if (soap_out_PointerTons1__CCompteurMachine(soap, "ns1:Machine", -1, &a->ns1__CountsByArticleResult::Machine, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CountsByArticleResult::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__CountsByArticleResult(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CountsByArticleResult * SOAP_FMAC4 soap_in_ns1__CountsByArticleResult(struct soap *soap, const char *tag, ns1__CountsByArticleResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CountsByArticleResult*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2_ns1__CountsByArticleResult, sizeof(ns1__CountsByArticleResult), soap->type, soap->arrayType, protocolv2_instantiate, protocolv2_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_protocolv2_ns1__CountsByArticleResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__CountsByArticleResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Machine1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Machine1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CCompteurMachine(soap, "ns1:Machine", &a->ns1__CountsByArticleResult::Machine, "ns1:CCompteurMachine"))
				{	soap_flag_Machine1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CountsByArticleResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2_ns1__CountsByArticleResult, SOAP_TYPE_protocolv2_ns1__CountsByArticleResult, sizeof(ns1__CountsByArticleResult), 0, protocolv2_finsert, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__CountsByArticleResult * SOAP_FMAC2 soap_instantiate_ns1__CountsByArticleResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CountsByArticleResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__CountsByArticleResult *p;
	size_t k = sizeof(ns1__CountsByArticleResult);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2_ns1__CountsByArticleResult, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__CountsByArticleResult);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__CountsByArticleResult, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__CountsByArticleResult location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__CountsByArticleResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__CountsByArticleResult(soap, tag ? tag : "ns1:CountsByArticleResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CountsByArticleResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CountsByArticleResult(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CountsByArticleResult * SOAP_FMAC4 soap_get_ns1__CountsByArticleResult(struct soap *soap, ns1__CountsByArticleResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CountsByArticleResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode;
	soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2_SOAP_ENV__Fault, SOAP_TYPE_protocolv2_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, protocolv2_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2_SOAP_ENV__Fault, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2_SOAP_ENV__Reason, SOAP_TYPE_protocolv2_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, protocolv2_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2_SOAP_ENV__Reason, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, "fault", &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2_SOAP_ENV__Detail, SOAP_TYPE_protocolv2_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, protocolv2_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2_SOAP_ENV__Detail, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value;
	soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2_SOAP_ENV__Code, SOAP_TYPE_protocolv2_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, protocolv2_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2_SOAP_ENV__Code, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_protocolv2_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_protocolv2_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_protocolv2_SOAP_ENV__Header, SOAP_TYPE_protocolv2_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, protocolv2_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2_SOAP_ENV__Header, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetLastRequestDate_(struct soap *soap, struct __ns1__GetLastRequestDate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetLastRequestDate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetLastRequestDate_(struct soap *soap, const struct __ns1__GetLastRequestDate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetLastRequestDate(soap, &a->ns1__GetLastRequestDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetLastRequestDate_(struct soap *soap, const char *tag, int id, const struct __ns1__GetLastRequestDate_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetLastRequestDate(soap, "ns1:GetLastRequestDate", -1, &a->ns1__GetLastRequestDate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLastRequestDate_ * SOAP_FMAC4 soap_in___ns1__GetLastRequestDate_(struct soap *soap, const char *tag, struct __ns1__GetLastRequestDate_ *a, const char *type)
{
	size_t soap_flag_ns1__GetLastRequestDate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetLastRequestDate_*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__GetLastRequestDate_, sizeof(struct __ns1__GetLastRequestDate_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetLastRequestDate_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetLastRequestDate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetLastRequestDate(soap, "ns1:GetLastRequestDate", &a->ns1__GetLastRequestDate, ""))
				{	soap_flag_ns1__GetLastRequestDate--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetLastRequestDate_ * SOAP_FMAC2 soap_instantiate___ns1__GetLastRequestDate_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetLastRequestDate_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetLastRequestDate_ *p;
	size_t k = sizeof(struct __ns1__GetLastRequestDate_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__GetLastRequestDate_, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetLastRequestDate_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetLastRequestDate_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetLastRequestDate_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetLastRequestDate_(struct soap *soap, const struct __ns1__GetLastRequestDate_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetLastRequestDate_(soap, tag ? tag : "-ns1:GetLastRequestDate", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLastRequestDate_ * SOAP_FMAC4 soap_get___ns1__GetLastRequestDate_(struct soap *soap, struct __ns1__GetLastRequestDate_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetLastRequestDate_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__AddSamples_(struct soap *soap, struct __ns1__AddSamples_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AddSamples = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__AddSamples_(struct soap *soap, const struct __ns1__AddSamples_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__AddSamples(soap, &a->ns1__AddSamples);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__AddSamples_(struct soap *soap, const char *tag, int id, const struct __ns1__AddSamples_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__AddSamples(soap, "ns1:AddSamples", -1, &a->ns1__AddSamples, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AddSamples_ * SOAP_FMAC4 soap_in___ns1__AddSamples_(struct soap *soap, const char *tag, struct __ns1__AddSamples_ *a, const char *type)
{
	size_t soap_flag_ns1__AddSamples = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__AddSamples_*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__AddSamples_, sizeof(struct __ns1__AddSamples_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__AddSamples_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AddSamples && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__AddSamples(soap, "ns1:AddSamples", &a->ns1__AddSamples, ""))
				{	soap_flag_ns1__AddSamples--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__AddSamples_ * SOAP_FMAC2 soap_instantiate___ns1__AddSamples_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__AddSamples_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__AddSamples_ *p;
	size_t k = sizeof(struct __ns1__AddSamples_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__AddSamples_, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__AddSamples_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__AddSamples_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__AddSamples_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__AddSamples_(struct soap *soap, const struct __ns1__AddSamples_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__AddSamples_(soap, tag ? tag : "-ns1:AddSamples", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AddSamples_ * SOAP_FMAC4 soap_get___ns1__AddSamples_(struct soap *soap, struct __ns1__AddSamples_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__AddSamples_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__AddEjectedMolds_(struct soap *soap, struct __ns1__AddEjectedMolds_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AddEjectedMolds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__AddEjectedMolds_(struct soap *soap, const struct __ns1__AddEjectedMolds_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__AddEjectedMolds(soap, &a->ns1__AddEjectedMolds);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__AddEjectedMolds_(struct soap *soap, const char *tag, int id, const struct __ns1__AddEjectedMolds_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__AddEjectedMolds(soap, "ns1:AddEjectedMolds", -1, &a->ns1__AddEjectedMolds, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AddEjectedMolds_ * SOAP_FMAC4 soap_in___ns1__AddEjectedMolds_(struct soap *soap, const char *tag, struct __ns1__AddEjectedMolds_ *a, const char *type)
{
	size_t soap_flag_ns1__AddEjectedMolds = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__AddEjectedMolds_*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__AddEjectedMolds_, sizeof(struct __ns1__AddEjectedMolds_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__AddEjectedMolds_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AddEjectedMolds && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__AddEjectedMolds(soap, "ns1:AddEjectedMolds", &a->ns1__AddEjectedMolds, ""))
				{	soap_flag_ns1__AddEjectedMolds--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__AddEjectedMolds_ * SOAP_FMAC2 soap_instantiate___ns1__AddEjectedMolds_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__AddEjectedMolds_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__AddEjectedMolds_ *p;
	size_t k = sizeof(struct __ns1__AddEjectedMolds_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__AddEjectedMolds_, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__AddEjectedMolds_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__AddEjectedMolds_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__AddEjectedMolds_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__AddEjectedMolds_(struct soap *soap, const struct __ns1__AddEjectedMolds_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__AddEjectedMolds_(soap, tag ? tag : "-ns1:AddEjectedMolds", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AddEjectedMolds_ * SOAP_FMAC4 soap_get___ns1__AddEjectedMolds_(struct soap *soap, struct __ns1__AddEjectedMolds_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__AddEjectedMolds_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__AddMountedMolds_(struct soap *soap, struct __ns1__AddMountedMolds_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AddMountedMolds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__AddMountedMolds_(struct soap *soap, const struct __ns1__AddMountedMolds_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__AddMountedMolds(soap, &a->ns1__AddMountedMolds);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__AddMountedMolds_(struct soap *soap, const char *tag, int id, const struct __ns1__AddMountedMolds_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__AddMountedMolds(soap, "ns1:AddMountedMolds", -1, &a->ns1__AddMountedMolds, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AddMountedMolds_ * SOAP_FMAC4 soap_in___ns1__AddMountedMolds_(struct soap *soap, const char *tag, struct __ns1__AddMountedMolds_ *a, const char *type)
{
	size_t soap_flag_ns1__AddMountedMolds = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__AddMountedMolds_*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__AddMountedMolds_, sizeof(struct __ns1__AddMountedMolds_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__AddMountedMolds_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AddMountedMolds && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__AddMountedMolds(soap, "ns1:AddMountedMolds", &a->ns1__AddMountedMolds, ""))
				{	soap_flag_ns1__AddMountedMolds--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__AddMountedMolds_ * SOAP_FMAC2 soap_instantiate___ns1__AddMountedMolds_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__AddMountedMolds_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__AddMountedMolds_ *p;
	size_t k = sizeof(struct __ns1__AddMountedMolds_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__AddMountedMolds_, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__AddMountedMolds_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__AddMountedMolds_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__AddMountedMolds_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__AddMountedMolds_(struct soap *soap, const struct __ns1__AddMountedMolds_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__AddMountedMolds_(soap, tag ? tag : "-ns1:AddMountedMolds", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AddMountedMolds_ * SOAP_FMAC4 soap_get___ns1__AddMountedMolds_(struct soap *soap, struct __ns1__AddMountedMolds_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__AddMountedMolds_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Samples_(struct soap *soap, struct __ns1__Samples_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Samples = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Samples_(struct soap *soap, const struct __ns1__Samples_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Samples(soap, &a->ns1__Samples);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Samples_(struct soap *soap, const char *tag, int id, const struct __ns1__Samples_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Samples(soap, "ns1:Samples", -1, &a->ns1__Samples, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Samples_ * SOAP_FMAC4 soap_in___ns1__Samples_(struct soap *soap, const char *tag, struct __ns1__Samples_ *a, const char *type)
{
	size_t soap_flag_ns1__Samples = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Samples_*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__Samples_, sizeof(struct __ns1__Samples_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Samples_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Samples && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Samples(soap, "ns1:Samples", &a->ns1__Samples, ""))
				{	soap_flag_ns1__Samples--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Samples_ * SOAP_FMAC2 soap_instantiate___ns1__Samples_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Samples_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Samples_ *p;
	size_t k = sizeof(struct __ns1__Samples_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__Samples_, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Samples_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Samples_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Samples_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Samples_(struct soap *soap, const struct __ns1__Samples_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Samples_(soap, tag ? tag : "-ns1:Samples", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Samples_ * SOAP_FMAC4 soap_get___ns1__Samples_(struct soap *soap, struct __ns1__Samples_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Samples_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Alarms_(struct soap *soap, struct __ns1__Alarms_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Alarms = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Alarms_(struct soap *soap, const struct __ns1__Alarms_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Alarms(soap, &a->ns1__Alarms);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Alarms_(struct soap *soap, const char *tag, int id, const struct __ns1__Alarms_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Alarms(soap, "ns1:Alarms", -1, &a->ns1__Alarms, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Alarms_ * SOAP_FMAC4 soap_in___ns1__Alarms_(struct soap *soap, const char *tag, struct __ns1__Alarms_ *a, const char *type)
{
	size_t soap_flag_ns1__Alarms = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Alarms_*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__Alarms_, sizeof(struct __ns1__Alarms_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Alarms_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Alarms && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Alarms(soap, "ns1:Alarms", &a->ns1__Alarms, ""))
				{	soap_flag_ns1__Alarms--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Alarms_ * SOAP_FMAC2 soap_instantiate___ns1__Alarms_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Alarms_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Alarms_ *p;
	size_t k = sizeof(struct __ns1__Alarms_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__Alarms_, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Alarms_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Alarms_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Alarms_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Alarms_(struct soap *soap, const struct __ns1__Alarms_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Alarms_(soap, tag ? tag : "-ns1:Alarms", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Alarms_ * SOAP_FMAC4 soap_get___ns1__Alarms_(struct soap *soap, struct __ns1__Alarms_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Alarms_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Measures_(struct soap *soap, struct __ns1__Measures_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Measures = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Measures_(struct soap *soap, const struct __ns1__Measures_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Measures(soap, &a->ns1__Measures);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Measures_(struct soap *soap, const char *tag, int id, const struct __ns1__Measures_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Measures(soap, "ns1:Measures", -1, &a->ns1__Measures, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Measures_ * SOAP_FMAC4 soap_in___ns1__Measures_(struct soap *soap, const char *tag, struct __ns1__Measures_ *a, const char *type)
{
	size_t soap_flag_ns1__Measures = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Measures_*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__Measures_, sizeof(struct __ns1__Measures_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Measures_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Measures && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Measures(soap, "ns1:Measures", &a->ns1__Measures, ""))
				{	soap_flag_ns1__Measures--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Measures_ * SOAP_FMAC2 soap_instantiate___ns1__Measures_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Measures_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Measures_ *p;
	size_t k = sizeof(struct __ns1__Measures_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__Measures_, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Measures_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Measures_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Measures_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Measures_(struct soap *soap, const struct __ns1__Measures_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Measures_(soap, tag ? tag : "-ns1:Measures", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Measures_ * SOAP_FMAC4 soap_get___ns1__Measures_(struct soap *soap, struct __ns1__Measures_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Measures_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ReadenMolds_(struct soap *soap, struct __ns1__ReadenMolds_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ReadenMolds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ReadenMolds_(struct soap *soap, const struct __ns1__ReadenMolds_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ReadenMolds(soap, &a->ns1__ReadenMolds);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ReadenMolds_(struct soap *soap, const char *tag, int id, const struct __ns1__ReadenMolds_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ReadenMolds(soap, "ns1:ReadenMolds", -1, &a->ns1__ReadenMolds, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ReadenMolds_ * SOAP_FMAC4 soap_in___ns1__ReadenMolds_(struct soap *soap, const char *tag, struct __ns1__ReadenMolds_ *a, const char *type)
{
	size_t soap_flag_ns1__ReadenMolds = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ReadenMolds_*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__ReadenMolds_, sizeof(struct __ns1__ReadenMolds_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ReadenMolds_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ReadenMolds && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ReadenMolds(soap, "ns1:ReadenMolds", &a->ns1__ReadenMolds, ""))
				{	soap_flag_ns1__ReadenMolds--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ReadenMolds_ * SOAP_FMAC2 soap_instantiate___ns1__ReadenMolds_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ReadenMolds_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ReadenMolds_ *p;
	size_t k = sizeof(struct __ns1__ReadenMolds_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__ReadenMolds_, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ReadenMolds_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ReadenMolds_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ReadenMolds_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ReadenMolds_(struct soap *soap, const struct __ns1__ReadenMolds_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ReadenMolds_(soap, tag ? tag : "-ns1:ReadenMolds", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ReadenMolds_ * SOAP_FMAC4 soap_get___ns1__ReadenMolds_(struct soap *soap, struct __ns1__ReadenMolds_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ReadenMolds_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__EjectedMolds_(struct soap *soap, struct __ns1__EjectedMolds_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__EjectedMolds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__EjectedMolds_(struct soap *soap, const struct __ns1__EjectedMolds_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__EjectedMolds(soap, &a->ns1__EjectedMolds);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__EjectedMolds_(struct soap *soap, const char *tag, int id, const struct __ns1__EjectedMolds_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__EjectedMolds(soap, "ns1:EjectedMolds", -1, &a->ns1__EjectedMolds, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EjectedMolds_ * SOAP_FMAC4 soap_in___ns1__EjectedMolds_(struct soap *soap, const char *tag, struct __ns1__EjectedMolds_ *a, const char *type)
{
	size_t soap_flag_ns1__EjectedMolds = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__EjectedMolds_*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__EjectedMolds_, sizeof(struct __ns1__EjectedMolds_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__EjectedMolds_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__EjectedMolds && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__EjectedMolds(soap, "ns1:EjectedMolds", &a->ns1__EjectedMolds, ""))
				{	soap_flag_ns1__EjectedMolds--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__EjectedMolds_ * SOAP_FMAC2 soap_instantiate___ns1__EjectedMolds_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__EjectedMolds_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__EjectedMolds_ *p;
	size_t k = sizeof(struct __ns1__EjectedMolds_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__EjectedMolds_, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__EjectedMolds_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__EjectedMolds_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__EjectedMolds_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__EjectedMolds_(struct soap *soap, const struct __ns1__EjectedMolds_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__EjectedMolds_(soap, tag ? tag : "-ns1:EjectedMolds", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EjectedMolds_ * SOAP_FMAC4 soap_get___ns1__EjectedMolds_(struct soap *soap, struct __ns1__EjectedMolds_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__EjectedMolds_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__MountedMolds_(struct soap *soap, struct __ns1__MountedMolds_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__MountedMolds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__MountedMolds_(struct soap *soap, const struct __ns1__MountedMolds_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__MountedMolds(soap, &a->ns1__MountedMolds);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__MountedMolds_(struct soap *soap, const char *tag, int id, const struct __ns1__MountedMolds_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__MountedMolds(soap, "ns1:MountedMolds", -1, &a->ns1__MountedMolds, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__MountedMolds_ * SOAP_FMAC4 soap_in___ns1__MountedMolds_(struct soap *soap, const char *tag, struct __ns1__MountedMolds_ *a, const char *type)
{
	size_t soap_flag_ns1__MountedMolds = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__MountedMolds_*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__MountedMolds_, sizeof(struct __ns1__MountedMolds_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__MountedMolds_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__MountedMolds && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__MountedMolds(soap, "ns1:MountedMolds", &a->ns1__MountedMolds, ""))
				{	soap_flag_ns1__MountedMolds--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__MountedMolds_ * SOAP_FMAC2 soap_instantiate___ns1__MountedMolds_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__MountedMolds_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__MountedMolds_ *p;
	size_t k = sizeof(struct __ns1__MountedMolds_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__MountedMolds_, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__MountedMolds_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__MountedMolds_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__MountedMolds_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__MountedMolds_(struct soap *soap, const struct __ns1__MountedMolds_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__MountedMolds_(soap, tag ? tag : "-ns1:MountedMolds", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__MountedMolds_ * SOAP_FMAC4 soap_get___ns1__MountedMolds_(struct soap *soap, struct __ns1__MountedMolds_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__MountedMolds_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetUpdatedLastRequestDate_(struct soap *soap, struct __ns1__GetUpdatedLastRequestDate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetUpdatedLastRequestDate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetUpdatedLastRequestDate_(struct soap *soap, const struct __ns1__GetUpdatedLastRequestDate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetUpdatedLastRequestDate(soap, &a->ns1__GetUpdatedLastRequestDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetUpdatedLastRequestDate_(struct soap *soap, const char *tag, int id, const struct __ns1__GetUpdatedLastRequestDate_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetUpdatedLastRequestDate(soap, "ns1:GetUpdatedLastRequestDate", -1, &a->ns1__GetUpdatedLastRequestDate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetUpdatedLastRequestDate_ * SOAP_FMAC4 soap_in___ns1__GetUpdatedLastRequestDate_(struct soap *soap, const char *tag, struct __ns1__GetUpdatedLastRequestDate_ *a, const char *type)
{
	size_t soap_flag_ns1__GetUpdatedLastRequestDate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetUpdatedLastRequestDate_*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__GetUpdatedLastRequestDate_, sizeof(struct __ns1__GetUpdatedLastRequestDate_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetUpdatedLastRequestDate_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetUpdatedLastRequestDate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetUpdatedLastRequestDate(soap, "ns1:GetUpdatedLastRequestDate", &a->ns1__GetUpdatedLastRequestDate, ""))
				{	soap_flag_ns1__GetUpdatedLastRequestDate--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetUpdatedLastRequestDate_ * SOAP_FMAC2 soap_instantiate___ns1__GetUpdatedLastRequestDate_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetUpdatedLastRequestDate_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetUpdatedLastRequestDate_ *p;
	size_t k = sizeof(struct __ns1__GetUpdatedLastRequestDate_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__GetUpdatedLastRequestDate_, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetUpdatedLastRequestDate_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetUpdatedLastRequestDate_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetUpdatedLastRequestDate_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetUpdatedLastRequestDate_(struct soap *soap, const struct __ns1__GetUpdatedLastRequestDate_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetUpdatedLastRequestDate_(soap, tag ? tag : "-ns1:GetUpdatedLastRequestDate", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetUpdatedLastRequestDate_ * SOAP_FMAC4 soap_get___ns1__GetUpdatedLastRequestDate_(struct soap *soap, struct __ns1__GetUpdatedLastRequestDate_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetUpdatedLastRequestDate_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__PreserveCounts_(struct soap *soap, struct __ns1__PreserveCounts_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PreserveCounts = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__PreserveCounts_(struct soap *soap, const struct __ns1__PreserveCounts_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__PreserveCounts(soap, &a->ns1__PreserveCounts);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__PreserveCounts_(struct soap *soap, const char *tag, int id, const struct __ns1__PreserveCounts_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__PreserveCounts(soap, "ns1:PreserveCounts", -1, &a->ns1__PreserveCounts, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__PreserveCounts_ * SOAP_FMAC4 soap_in___ns1__PreserveCounts_(struct soap *soap, const char *tag, struct __ns1__PreserveCounts_ *a, const char *type)
{
	size_t soap_flag_ns1__PreserveCounts = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__PreserveCounts_*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__PreserveCounts_, sizeof(struct __ns1__PreserveCounts_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__PreserveCounts_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PreserveCounts && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__PreserveCounts(soap, "ns1:PreserveCounts", &a->ns1__PreserveCounts, ""))
				{	soap_flag_ns1__PreserveCounts--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__PreserveCounts_ * SOAP_FMAC2 soap_instantiate___ns1__PreserveCounts_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__PreserveCounts_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__PreserveCounts_ *p;
	size_t k = sizeof(struct __ns1__PreserveCounts_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__PreserveCounts_, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__PreserveCounts_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__PreserveCounts_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__PreserveCounts_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__PreserveCounts_(struct soap *soap, const struct __ns1__PreserveCounts_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__PreserveCounts_(soap, tag ? tag : "-ns1:PreserveCounts", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__PreserveCounts_ * SOAP_FMAC4 soap_get___ns1__PreserveCounts_(struct soap *soap, struct __ns1__PreserveCounts_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__PreserveCounts_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CountsByArticle_(struct soap *soap, struct __ns1__CountsByArticle_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CountsByArticle = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CountsByArticle_(struct soap *soap, const struct __ns1__CountsByArticle_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CountsByArticle(soap, &a->ns1__CountsByArticle);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CountsByArticle_(struct soap *soap, const char *tag, int id, const struct __ns1__CountsByArticle_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CountsByArticle(soap, "ns1:CountsByArticle", -1, &a->ns1__CountsByArticle, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CountsByArticle_ * SOAP_FMAC4 soap_in___ns1__CountsByArticle_(struct soap *soap, const char *tag, struct __ns1__CountsByArticle_ *a, const char *type)
{
	size_t soap_flag_ns1__CountsByArticle = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CountsByArticle_*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__CountsByArticle_, sizeof(struct __ns1__CountsByArticle_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CountsByArticle_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CountsByArticle && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CountsByArticle(soap, "ns1:CountsByArticle", &a->ns1__CountsByArticle, ""))
				{	soap_flag_ns1__CountsByArticle--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CountsByArticle_ * SOAP_FMAC2 soap_instantiate___ns1__CountsByArticle_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CountsByArticle_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CountsByArticle_ *p;
	size_t k = sizeof(struct __ns1__CountsByArticle_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__CountsByArticle_, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__CountsByArticle_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__CountsByArticle_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CountsByArticle_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CountsByArticle_(struct soap *soap, const struct __ns1__CountsByArticle_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CountsByArticle_(soap, tag ? tag : "-ns1:CountsByArticle", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CountsByArticle_ * SOAP_FMAC4 soap_get___ns1__CountsByArticle_(struct soap *soap, struct __ns1__CountsByArticle_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CountsByArticle_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Counts_(struct soap *soap, struct __ns1__Counts_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Counts = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Counts_(struct soap *soap, const struct __ns1__Counts_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Counts(soap, &a->ns1__Counts);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Counts_(struct soap *soap, const char *tag, int id, const struct __ns1__Counts_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Counts(soap, "ns1:Counts", -1, &a->ns1__Counts, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Counts_ * SOAP_FMAC4 soap_in___ns1__Counts_(struct soap *soap, const char *tag, struct __ns1__Counts_ *a, const char *type)
{
	size_t soap_flag_ns1__Counts = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Counts_*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__Counts_, sizeof(struct __ns1__Counts_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Counts_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Counts && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Counts(soap, "ns1:Counts", &a->ns1__Counts, ""))
				{	soap_flag_ns1__Counts--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Counts_ * SOAP_FMAC2 soap_instantiate___ns1__Counts_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Counts_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Counts_ *p;
	size_t k = sizeof(struct __ns1__Counts_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__Counts_, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Counts_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Counts_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Counts_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Counts_(struct soap *soap, const struct __ns1__Counts_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Counts_(soap, tag ? tag : "-ns1:Counts", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Counts_ * SOAP_FMAC4 soap_get___ns1__Counts_(struct soap *soap, struct __ns1__Counts_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Counts_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetLastRequestDate(struct soap *soap, struct __ns1__GetLastRequestDate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetLastRequestDate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetLastRequestDate(struct soap *soap, const struct __ns1__GetLastRequestDate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetLastRequestDate(soap, &a->ns1__GetLastRequestDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetLastRequestDate(struct soap *soap, const char *tag, int id, const struct __ns1__GetLastRequestDate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetLastRequestDate(soap, "ns1:GetLastRequestDate", -1, &a->ns1__GetLastRequestDate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLastRequestDate * SOAP_FMAC4 soap_in___ns1__GetLastRequestDate(struct soap *soap, const char *tag, struct __ns1__GetLastRequestDate *a, const char *type)
{
	size_t soap_flag_ns1__GetLastRequestDate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetLastRequestDate*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__GetLastRequestDate, sizeof(struct __ns1__GetLastRequestDate), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetLastRequestDate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetLastRequestDate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetLastRequestDate(soap, "ns1:GetLastRequestDate", &a->ns1__GetLastRequestDate, ""))
				{	soap_flag_ns1__GetLastRequestDate--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetLastRequestDate * SOAP_FMAC2 soap_instantiate___ns1__GetLastRequestDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetLastRequestDate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetLastRequestDate *p;
	size_t k = sizeof(struct __ns1__GetLastRequestDate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__GetLastRequestDate, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetLastRequestDate);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetLastRequestDate, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetLastRequestDate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetLastRequestDate(struct soap *soap, const struct __ns1__GetLastRequestDate *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetLastRequestDate(soap, tag ? tag : "-ns1:GetLastRequestDate", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLastRequestDate * SOAP_FMAC4 soap_get___ns1__GetLastRequestDate(struct soap *soap, struct __ns1__GetLastRequestDate *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetLastRequestDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__AddSamples(struct soap *soap, struct __ns1__AddSamples *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AddSamples = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__AddSamples(struct soap *soap, const struct __ns1__AddSamples *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__AddSamples(soap, &a->ns1__AddSamples);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__AddSamples(struct soap *soap, const char *tag, int id, const struct __ns1__AddSamples *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__AddSamples(soap, "ns1:AddSamples", -1, &a->ns1__AddSamples, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AddSamples * SOAP_FMAC4 soap_in___ns1__AddSamples(struct soap *soap, const char *tag, struct __ns1__AddSamples *a, const char *type)
{
	size_t soap_flag_ns1__AddSamples = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__AddSamples*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__AddSamples, sizeof(struct __ns1__AddSamples), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__AddSamples(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AddSamples && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__AddSamples(soap, "ns1:AddSamples", &a->ns1__AddSamples, ""))
				{	soap_flag_ns1__AddSamples--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__AddSamples * SOAP_FMAC2 soap_instantiate___ns1__AddSamples(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__AddSamples(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__AddSamples *p;
	size_t k = sizeof(struct __ns1__AddSamples);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__AddSamples, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__AddSamples);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__AddSamples, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__AddSamples location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__AddSamples(struct soap *soap, const struct __ns1__AddSamples *a, const char *tag, const char *type)
{
	if (soap_out___ns1__AddSamples(soap, tag ? tag : "-ns1:AddSamples", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AddSamples * SOAP_FMAC4 soap_get___ns1__AddSamples(struct soap *soap, struct __ns1__AddSamples *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__AddSamples(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__AddEjectedMolds(struct soap *soap, struct __ns1__AddEjectedMolds *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AddEjectedMolds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__AddEjectedMolds(struct soap *soap, const struct __ns1__AddEjectedMolds *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__AddEjectedMolds(soap, &a->ns1__AddEjectedMolds);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__AddEjectedMolds(struct soap *soap, const char *tag, int id, const struct __ns1__AddEjectedMolds *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__AddEjectedMolds(soap, "ns1:AddEjectedMolds", -1, &a->ns1__AddEjectedMolds, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AddEjectedMolds * SOAP_FMAC4 soap_in___ns1__AddEjectedMolds(struct soap *soap, const char *tag, struct __ns1__AddEjectedMolds *a, const char *type)
{
	size_t soap_flag_ns1__AddEjectedMolds = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__AddEjectedMolds*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__AddEjectedMolds, sizeof(struct __ns1__AddEjectedMolds), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__AddEjectedMolds(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AddEjectedMolds && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__AddEjectedMolds(soap, "ns1:AddEjectedMolds", &a->ns1__AddEjectedMolds, ""))
				{	soap_flag_ns1__AddEjectedMolds--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__AddEjectedMolds * SOAP_FMAC2 soap_instantiate___ns1__AddEjectedMolds(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__AddEjectedMolds(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__AddEjectedMolds *p;
	size_t k = sizeof(struct __ns1__AddEjectedMolds);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__AddEjectedMolds, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__AddEjectedMolds);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__AddEjectedMolds, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__AddEjectedMolds location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__AddEjectedMolds(struct soap *soap, const struct __ns1__AddEjectedMolds *a, const char *tag, const char *type)
{
	if (soap_out___ns1__AddEjectedMolds(soap, tag ? tag : "-ns1:AddEjectedMolds", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AddEjectedMolds * SOAP_FMAC4 soap_get___ns1__AddEjectedMolds(struct soap *soap, struct __ns1__AddEjectedMolds *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__AddEjectedMolds(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__AddMountedMolds(struct soap *soap, struct __ns1__AddMountedMolds *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AddMountedMolds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__AddMountedMolds(struct soap *soap, const struct __ns1__AddMountedMolds *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__AddMountedMolds(soap, &a->ns1__AddMountedMolds);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__AddMountedMolds(struct soap *soap, const char *tag, int id, const struct __ns1__AddMountedMolds *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__AddMountedMolds(soap, "ns1:AddMountedMolds", -1, &a->ns1__AddMountedMolds, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AddMountedMolds * SOAP_FMAC4 soap_in___ns1__AddMountedMolds(struct soap *soap, const char *tag, struct __ns1__AddMountedMolds *a, const char *type)
{
	size_t soap_flag_ns1__AddMountedMolds = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__AddMountedMolds*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__AddMountedMolds, sizeof(struct __ns1__AddMountedMolds), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__AddMountedMolds(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AddMountedMolds && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__AddMountedMolds(soap, "ns1:AddMountedMolds", &a->ns1__AddMountedMolds, ""))
				{	soap_flag_ns1__AddMountedMolds--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__AddMountedMolds * SOAP_FMAC2 soap_instantiate___ns1__AddMountedMolds(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__AddMountedMolds(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__AddMountedMolds *p;
	size_t k = sizeof(struct __ns1__AddMountedMolds);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__AddMountedMolds, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__AddMountedMolds);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__AddMountedMolds, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__AddMountedMolds location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__AddMountedMolds(struct soap *soap, const struct __ns1__AddMountedMolds *a, const char *tag, const char *type)
{
	if (soap_out___ns1__AddMountedMolds(soap, tag ? tag : "-ns1:AddMountedMolds", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AddMountedMolds * SOAP_FMAC4 soap_get___ns1__AddMountedMolds(struct soap *soap, struct __ns1__AddMountedMolds *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__AddMountedMolds(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Samples(struct soap *soap, struct __ns1__Samples *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Samples = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Samples(struct soap *soap, const struct __ns1__Samples *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Samples(soap, &a->ns1__Samples);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Samples(struct soap *soap, const char *tag, int id, const struct __ns1__Samples *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Samples(soap, "ns1:Samples", -1, &a->ns1__Samples, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Samples * SOAP_FMAC4 soap_in___ns1__Samples(struct soap *soap, const char *tag, struct __ns1__Samples *a, const char *type)
{
	size_t soap_flag_ns1__Samples = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Samples*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__Samples, sizeof(struct __ns1__Samples), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Samples(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Samples && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Samples(soap, "ns1:Samples", &a->ns1__Samples, ""))
				{	soap_flag_ns1__Samples--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Samples * SOAP_FMAC2 soap_instantiate___ns1__Samples(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Samples(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Samples *p;
	size_t k = sizeof(struct __ns1__Samples);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__Samples, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Samples);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Samples, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Samples location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Samples(struct soap *soap, const struct __ns1__Samples *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Samples(soap, tag ? tag : "-ns1:Samples", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Samples * SOAP_FMAC4 soap_get___ns1__Samples(struct soap *soap, struct __ns1__Samples *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Samples(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Alarms(struct soap *soap, struct __ns1__Alarms *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Alarms = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Alarms(struct soap *soap, const struct __ns1__Alarms *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Alarms(soap, &a->ns1__Alarms);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Alarms(struct soap *soap, const char *tag, int id, const struct __ns1__Alarms *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Alarms(soap, "ns1:Alarms", -1, &a->ns1__Alarms, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Alarms * SOAP_FMAC4 soap_in___ns1__Alarms(struct soap *soap, const char *tag, struct __ns1__Alarms *a, const char *type)
{
	size_t soap_flag_ns1__Alarms = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Alarms*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__Alarms, sizeof(struct __ns1__Alarms), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Alarms(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Alarms && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Alarms(soap, "ns1:Alarms", &a->ns1__Alarms, ""))
				{	soap_flag_ns1__Alarms--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Alarms * SOAP_FMAC2 soap_instantiate___ns1__Alarms(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Alarms(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Alarms *p;
	size_t k = sizeof(struct __ns1__Alarms);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__Alarms, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Alarms);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Alarms, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Alarms location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Alarms(struct soap *soap, const struct __ns1__Alarms *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Alarms(soap, tag ? tag : "-ns1:Alarms", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Alarms * SOAP_FMAC4 soap_get___ns1__Alarms(struct soap *soap, struct __ns1__Alarms *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Alarms(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Measures(struct soap *soap, struct __ns1__Measures *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Measures = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Measures(struct soap *soap, const struct __ns1__Measures *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Measures(soap, &a->ns1__Measures);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Measures(struct soap *soap, const char *tag, int id, const struct __ns1__Measures *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Measures(soap, "ns1:Measures", -1, &a->ns1__Measures, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Measures * SOAP_FMAC4 soap_in___ns1__Measures(struct soap *soap, const char *tag, struct __ns1__Measures *a, const char *type)
{
	size_t soap_flag_ns1__Measures = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Measures*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__Measures, sizeof(struct __ns1__Measures), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Measures(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Measures && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Measures(soap, "ns1:Measures", &a->ns1__Measures, ""))
				{	soap_flag_ns1__Measures--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Measures * SOAP_FMAC2 soap_instantiate___ns1__Measures(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Measures(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Measures *p;
	size_t k = sizeof(struct __ns1__Measures);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__Measures, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Measures);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Measures, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Measures location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Measures(struct soap *soap, const struct __ns1__Measures *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Measures(soap, tag ? tag : "-ns1:Measures", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Measures * SOAP_FMAC4 soap_get___ns1__Measures(struct soap *soap, struct __ns1__Measures *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Measures(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ReadenMolds(struct soap *soap, struct __ns1__ReadenMolds *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ReadenMolds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ReadenMolds(struct soap *soap, const struct __ns1__ReadenMolds *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ReadenMolds(soap, &a->ns1__ReadenMolds);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ReadenMolds(struct soap *soap, const char *tag, int id, const struct __ns1__ReadenMolds *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ReadenMolds(soap, "ns1:ReadenMolds", -1, &a->ns1__ReadenMolds, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ReadenMolds * SOAP_FMAC4 soap_in___ns1__ReadenMolds(struct soap *soap, const char *tag, struct __ns1__ReadenMolds *a, const char *type)
{
	size_t soap_flag_ns1__ReadenMolds = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ReadenMolds*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__ReadenMolds, sizeof(struct __ns1__ReadenMolds), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ReadenMolds(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ReadenMolds && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ReadenMolds(soap, "ns1:ReadenMolds", &a->ns1__ReadenMolds, ""))
				{	soap_flag_ns1__ReadenMolds--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ReadenMolds * SOAP_FMAC2 soap_instantiate___ns1__ReadenMolds(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ReadenMolds(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ReadenMolds *p;
	size_t k = sizeof(struct __ns1__ReadenMolds);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__ReadenMolds, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ReadenMolds);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ReadenMolds, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ReadenMolds location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ReadenMolds(struct soap *soap, const struct __ns1__ReadenMolds *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ReadenMolds(soap, tag ? tag : "-ns1:ReadenMolds", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ReadenMolds * SOAP_FMAC4 soap_get___ns1__ReadenMolds(struct soap *soap, struct __ns1__ReadenMolds *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ReadenMolds(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__EjectedMolds(struct soap *soap, struct __ns1__EjectedMolds *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__EjectedMolds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__EjectedMolds(struct soap *soap, const struct __ns1__EjectedMolds *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__EjectedMolds(soap, &a->ns1__EjectedMolds);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__EjectedMolds(struct soap *soap, const char *tag, int id, const struct __ns1__EjectedMolds *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__EjectedMolds(soap, "ns1:EjectedMolds", -1, &a->ns1__EjectedMolds, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EjectedMolds * SOAP_FMAC4 soap_in___ns1__EjectedMolds(struct soap *soap, const char *tag, struct __ns1__EjectedMolds *a, const char *type)
{
	size_t soap_flag_ns1__EjectedMolds = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__EjectedMolds*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__EjectedMolds, sizeof(struct __ns1__EjectedMolds), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__EjectedMolds(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__EjectedMolds && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__EjectedMolds(soap, "ns1:EjectedMolds", &a->ns1__EjectedMolds, ""))
				{	soap_flag_ns1__EjectedMolds--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__EjectedMolds * SOAP_FMAC2 soap_instantiate___ns1__EjectedMolds(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__EjectedMolds(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__EjectedMolds *p;
	size_t k = sizeof(struct __ns1__EjectedMolds);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__EjectedMolds, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__EjectedMolds);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__EjectedMolds, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__EjectedMolds location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__EjectedMolds(struct soap *soap, const struct __ns1__EjectedMolds *a, const char *tag, const char *type)
{
	if (soap_out___ns1__EjectedMolds(soap, tag ? tag : "-ns1:EjectedMolds", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EjectedMolds * SOAP_FMAC4 soap_get___ns1__EjectedMolds(struct soap *soap, struct __ns1__EjectedMolds *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__EjectedMolds(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__MountedMolds(struct soap *soap, struct __ns1__MountedMolds *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__MountedMolds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__MountedMolds(struct soap *soap, const struct __ns1__MountedMolds *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__MountedMolds(soap, &a->ns1__MountedMolds);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__MountedMolds(struct soap *soap, const char *tag, int id, const struct __ns1__MountedMolds *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__MountedMolds(soap, "ns1:MountedMolds", -1, &a->ns1__MountedMolds, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__MountedMolds * SOAP_FMAC4 soap_in___ns1__MountedMolds(struct soap *soap, const char *tag, struct __ns1__MountedMolds *a, const char *type)
{
	size_t soap_flag_ns1__MountedMolds = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__MountedMolds*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__MountedMolds, sizeof(struct __ns1__MountedMolds), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__MountedMolds(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__MountedMolds && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__MountedMolds(soap, "ns1:MountedMolds", &a->ns1__MountedMolds, ""))
				{	soap_flag_ns1__MountedMolds--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__MountedMolds * SOAP_FMAC2 soap_instantiate___ns1__MountedMolds(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__MountedMolds(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__MountedMolds *p;
	size_t k = sizeof(struct __ns1__MountedMolds);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__MountedMolds, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__MountedMolds);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__MountedMolds, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__MountedMolds location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__MountedMolds(struct soap *soap, const struct __ns1__MountedMolds *a, const char *tag, const char *type)
{
	if (soap_out___ns1__MountedMolds(soap, tag ? tag : "-ns1:MountedMolds", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__MountedMolds * SOAP_FMAC4 soap_get___ns1__MountedMolds(struct soap *soap, struct __ns1__MountedMolds *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__MountedMolds(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetUpdatedLastRequestDate(struct soap *soap, struct __ns1__GetUpdatedLastRequestDate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetUpdatedLastRequestDate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetUpdatedLastRequestDate(struct soap *soap, const struct __ns1__GetUpdatedLastRequestDate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetUpdatedLastRequestDate(soap, &a->ns1__GetUpdatedLastRequestDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetUpdatedLastRequestDate(struct soap *soap, const char *tag, int id, const struct __ns1__GetUpdatedLastRequestDate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetUpdatedLastRequestDate(soap, "ns1:GetUpdatedLastRequestDate", -1, &a->ns1__GetUpdatedLastRequestDate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetUpdatedLastRequestDate * SOAP_FMAC4 soap_in___ns1__GetUpdatedLastRequestDate(struct soap *soap, const char *tag, struct __ns1__GetUpdatedLastRequestDate *a, const char *type)
{
	size_t soap_flag_ns1__GetUpdatedLastRequestDate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetUpdatedLastRequestDate*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__GetUpdatedLastRequestDate, sizeof(struct __ns1__GetUpdatedLastRequestDate), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetUpdatedLastRequestDate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetUpdatedLastRequestDate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetUpdatedLastRequestDate(soap, "ns1:GetUpdatedLastRequestDate", &a->ns1__GetUpdatedLastRequestDate, ""))
				{	soap_flag_ns1__GetUpdatedLastRequestDate--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetUpdatedLastRequestDate * SOAP_FMAC2 soap_instantiate___ns1__GetUpdatedLastRequestDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetUpdatedLastRequestDate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetUpdatedLastRequestDate *p;
	size_t k = sizeof(struct __ns1__GetUpdatedLastRequestDate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__GetUpdatedLastRequestDate, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetUpdatedLastRequestDate);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetUpdatedLastRequestDate, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetUpdatedLastRequestDate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetUpdatedLastRequestDate(struct soap *soap, const struct __ns1__GetUpdatedLastRequestDate *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetUpdatedLastRequestDate(soap, tag ? tag : "-ns1:GetUpdatedLastRequestDate", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetUpdatedLastRequestDate * SOAP_FMAC4 soap_get___ns1__GetUpdatedLastRequestDate(struct soap *soap, struct __ns1__GetUpdatedLastRequestDate *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetUpdatedLastRequestDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__PreserveCounts(struct soap *soap, struct __ns1__PreserveCounts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PreserveCounts = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__PreserveCounts(struct soap *soap, const struct __ns1__PreserveCounts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__PreserveCounts(soap, &a->ns1__PreserveCounts);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__PreserveCounts(struct soap *soap, const char *tag, int id, const struct __ns1__PreserveCounts *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__PreserveCounts(soap, "ns1:PreserveCounts", -1, &a->ns1__PreserveCounts, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__PreserveCounts * SOAP_FMAC4 soap_in___ns1__PreserveCounts(struct soap *soap, const char *tag, struct __ns1__PreserveCounts *a, const char *type)
{
	size_t soap_flag_ns1__PreserveCounts = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__PreserveCounts*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__PreserveCounts, sizeof(struct __ns1__PreserveCounts), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__PreserveCounts(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PreserveCounts && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__PreserveCounts(soap, "ns1:PreserveCounts", &a->ns1__PreserveCounts, ""))
				{	soap_flag_ns1__PreserveCounts--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__PreserveCounts * SOAP_FMAC2 soap_instantiate___ns1__PreserveCounts(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__PreserveCounts(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__PreserveCounts *p;
	size_t k = sizeof(struct __ns1__PreserveCounts);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__PreserveCounts, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__PreserveCounts);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__PreserveCounts, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__PreserveCounts location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__PreserveCounts(struct soap *soap, const struct __ns1__PreserveCounts *a, const char *tag, const char *type)
{
	if (soap_out___ns1__PreserveCounts(soap, tag ? tag : "-ns1:PreserveCounts", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__PreserveCounts * SOAP_FMAC4 soap_get___ns1__PreserveCounts(struct soap *soap, struct __ns1__PreserveCounts *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__PreserveCounts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CountsByArticle(struct soap *soap, struct __ns1__CountsByArticle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CountsByArticle = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CountsByArticle(struct soap *soap, const struct __ns1__CountsByArticle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CountsByArticle(soap, &a->ns1__CountsByArticle);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CountsByArticle(struct soap *soap, const char *tag, int id, const struct __ns1__CountsByArticle *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CountsByArticle(soap, "ns1:CountsByArticle", -1, &a->ns1__CountsByArticle, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CountsByArticle * SOAP_FMAC4 soap_in___ns1__CountsByArticle(struct soap *soap, const char *tag, struct __ns1__CountsByArticle *a, const char *type)
{
	size_t soap_flag_ns1__CountsByArticle = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CountsByArticle*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__CountsByArticle, sizeof(struct __ns1__CountsByArticle), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CountsByArticle(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CountsByArticle && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CountsByArticle(soap, "ns1:CountsByArticle", &a->ns1__CountsByArticle, ""))
				{	soap_flag_ns1__CountsByArticle--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CountsByArticle * SOAP_FMAC2 soap_instantiate___ns1__CountsByArticle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CountsByArticle(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CountsByArticle *p;
	size_t k = sizeof(struct __ns1__CountsByArticle);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__CountsByArticle, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__CountsByArticle);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__CountsByArticle, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CountsByArticle location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CountsByArticle(struct soap *soap, const struct __ns1__CountsByArticle *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CountsByArticle(soap, tag ? tag : "-ns1:CountsByArticle", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CountsByArticle * SOAP_FMAC4 soap_get___ns1__CountsByArticle(struct soap *soap, struct __ns1__CountsByArticle *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CountsByArticle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Counts(struct soap *soap, struct __ns1__Counts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Counts = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Counts(struct soap *soap, const struct __ns1__Counts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Counts(soap, &a->ns1__Counts);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Counts(struct soap *soap, const char *tag, int id, const struct __ns1__Counts *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Counts(soap, "ns1:Counts", -1, &a->ns1__Counts, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Counts * SOAP_FMAC4 soap_in___ns1__Counts(struct soap *soap, const char *tag, struct __ns1__Counts *a, const char *type)
{
	size_t soap_flag_ns1__Counts = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Counts*)soap_id_enter(soap, "", a, SOAP_TYPE_protocolv2___ns1__Counts, sizeof(struct __ns1__Counts), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Counts(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Counts && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Counts(soap, "ns1:Counts", &a->ns1__Counts, ""))
				{	soap_flag_ns1__Counts--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Counts * SOAP_FMAC2 soap_instantiate___ns1__Counts(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Counts(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Counts *p;
	size_t k = sizeof(struct __ns1__Counts);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_protocolv2___ns1__Counts, n, protocolv2_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Counts);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Counts, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Counts location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Counts(struct soap *soap, const struct __ns1__Counts *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Counts(soap, tag ? tag : "-ns1:Counts", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Counts * SOAP_FMAC4 soap_get___ns1__Counts(struct soap *soap, struct __ns1__Counts *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Counts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_protocolv2_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_protocolv2_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_protocolv2_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_protocolv2_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_protocolv2_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_protocolv2_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_protocolv2_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_protocolv2_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_protocolv2_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetLastRequestDate(struct soap *soap, _ns1__GetLastRequestDate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_protocolv2__ns1__GetLastRequestDate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetLastRequestDate(struct soap *soap, const char *tag, int id, _ns1__GetLastRequestDate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_protocolv2__ns1__GetLastRequestDate, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_protocolv2__ns1__GetLastRequestDate ? type : NULL);
}

SOAP_FMAC3 _ns1__GetLastRequestDate ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetLastRequestDate(struct soap *soap, const char *tag, _ns1__GetLastRequestDate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetLastRequestDate **)soap_malloc(soap, sizeof(_ns1__GetLastRequestDate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetLastRequestDate *)soap_instantiate__ns1__GetLastRequestDate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetLastRequestDate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_protocolv2__ns1__GetLastRequestDate, sizeof(_ns1__GetLastRequestDate), 0, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetLastRequestDate(struct soap *soap, _ns1__GetLastRequestDate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetLastRequestDate(soap, tag ? tag : "ns1:GetLastRequestDate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetLastRequestDate ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetLastRequestDate(struct soap *soap, _ns1__GetLastRequestDate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetLastRequestDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AddSamples(struct soap *soap, _ns1__AddSamples *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_protocolv2__ns1__AddSamples))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AddSamples(struct soap *soap, const char *tag, int id, _ns1__AddSamples *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_protocolv2__ns1__AddSamples, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_protocolv2__ns1__AddSamples ? type : NULL);
}

SOAP_FMAC3 _ns1__AddSamples ** SOAP_FMAC4 soap_in_PointerTo_ns1__AddSamples(struct soap *soap, const char *tag, _ns1__AddSamples **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AddSamples **)soap_malloc(soap, sizeof(_ns1__AddSamples *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AddSamples *)soap_instantiate__ns1__AddSamples(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__AddSamples **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_protocolv2__ns1__AddSamples, sizeof(_ns1__AddSamples), 0, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AddSamples(struct soap *soap, _ns1__AddSamples *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__AddSamples(soap, tag ? tag : "ns1:AddSamples", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AddSamples ** SOAP_FMAC4 soap_get_PointerTo_ns1__AddSamples(struct soap *soap, _ns1__AddSamples **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AddSamples(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AddEjectedMolds(struct soap *soap, _ns1__AddEjectedMolds *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_protocolv2__ns1__AddEjectedMolds))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AddEjectedMolds(struct soap *soap, const char *tag, int id, _ns1__AddEjectedMolds *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_protocolv2__ns1__AddEjectedMolds, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_protocolv2__ns1__AddEjectedMolds ? type : NULL);
}

SOAP_FMAC3 _ns1__AddEjectedMolds ** SOAP_FMAC4 soap_in_PointerTo_ns1__AddEjectedMolds(struct soap *soap, const char *tag, _ns1__AddEjectedMolds **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AddEjectedMolds **)soap_malloc(soap, sizeof(_ns1__AddEjectedMolds *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AddEjectedMolds *)soap_instantiate__ns1__AddEjectedMolds(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__AddEjectedMolds **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_protocolv2__ns1__AddEjectedMolds, sizeof(_ns1__AddEjectedMolds), 0, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AddEjectedMolds(struct soap *soap, _ns1__AddEjectedMolds *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__AddEjectedMolds(soap, tag ? tag : "ns1:AddEjectedMolds", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AddEjectedMolds ** SOAP_FMAC4 soap_get_PointerTo_ns1__AddEjectedMolds(struct soap *soap, _ns1__AddEjectedMolds **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AddEjectedMolds(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AddMountedMolds(struct soap *soap, _ns1__AddMountedMolds *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_protocolv2__ns1__AddMountedMolds))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AddMountedMolds(struct soap *soap, const char *tag, int id, _ns1__AddMountedMolds *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_protocolv2__ns1__AddMountedMolds, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_protocolv2__ns1__AddMountedMolds ? type : NULL);
}

SOAP_FMAC3 _ns1__AddMountedMolds ** SOAP_FMAC4 soap_in_PointerTo_ns1__AddMountedMolds(struct soap *soap, const char *tag, _ns1__AddMountedMolds **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AddMountedMolds **)soap_malloc(soap, sizeof(_ns1__AddMountedMolds *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AddMountedMolds *)soap_instantiate__ns1__AddMountedMolds(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__AddMountedMolds **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_protocolv2__ns1__AddMountedMolds, sizeof(_ns1__AddMountedMolds), 0, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AddMountedMolds(struct soap *soap, _ns1__AddMountedMolds *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__AddMountedMolds(soap, tag ? tag : "ns1:AddMountedMolds", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AddMountedMolds ** SOAP_FMAC4 soap_get_PointerTo_ns1__AddMountedMolds(struct soap *soap, _ns1__AddMountedMolds **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AddMountedMolds(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Samples(struct soap *soap, _ns1__Samples *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_protocolv2__ns1__Samples))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Samples(struct soap *soap, const char *tag, int id, _ns1__Samples *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_protocolv2__ns1__Samples, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_protocolv2__ns1__Samples ? type : NULL);
}

SOAP_FMAC3 _ns1__Samples ** SOAP_FMAC4 soap_in_PointerTo_ns1__Samples(struct soap *soap, const char *tag, _ns1__Samples **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Samples **)soap_malloc(soap, sizeof(_ns1__Samples *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Samples *)soap_instantiate__ns1__Samples(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__Samples **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_protocolv2__ns1__Samples, sizeof(_ns1__Samples), 0, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Samples(struct soap *soap, _ns1__Samples *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__Samples(soap, tag ? tag : "ns1:Samples", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Samples ** SOAP_FMAC4 soap_get_PointerTo_ns1__Samples(struct soap *soap, _ns1__Samples **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Samples(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Alarms(struct soap *soap, _ns1__Alarms *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_protocolv2__ns1__Alarms))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Alarms(struct soap *soap, const char *tag, int id, _ns1__Alarms *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_protocolv2__ns1__Alarms, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_protocolv2__ns1__Alarms ? type : NULL);
}

SOAP_FMAC3 _ns1__Alarms ** SOAP_FMAC4 soap_in_PointerTo_ns1__Alarms(struct soap *soap, const char *tag, _ns1__Alarms **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Alarms **)soap_malloc(soap, sizeof(_ns1__Alarms *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Alarms *)soap_instantiate__ns1__Alarms(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__Alarms **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_protocolv2__ns1__Alarms, sizeof(_ns1__Alarms), 0, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Alarms(struct soap *soap, _ns1__Alarms *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__Alarms(soap, tag ? tag : "ns1:Alarms", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Alarms ** SOAP_FMAC4 soap_get_PointerTo_ns1__Alarms(struct soap *soap, _ns1__Alarms **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Alarms(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Measures(struct soap *soap, _ns1__Measures *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_protocolv2__ns1__Measures))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Measures(struct soap *soap, const char *tag, int id, _ns1__Measures *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_protocolv2__ns1__Measures, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_protocolv2__ns1__Measures ? type : NULL);
}

SOAP_FMAC3 _ns1__Measures ** SOAP_FMAC4 soap_in_PointerTo_ns1__Measures(struct soap *soap, const char *tag, _ns1__Measures **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Measures **)soap_malloc(soap, sizeof(_ns1__Measures *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Measures *)soap_instantiate__ns1__Measures(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__Measures **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_protocolv2__ns1__Measures, sizeof(_ns1__Measures), 0, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Measures(struct soap *soap, _ns1__Measures *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__Measures(soap, tag ? tag : "ns1:Measures", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Measures ** SOAP_FMAC4 soap_get_PointerTo_ns1__Measures(struct soap *soap, _ns1__Measures **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Measures(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ReadenMolds(struct soap *soap, _ns1__ReadenMolds *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_protocolv2__ns1__ReadenMolds))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ReadenMolds(struct soap *soap, const char *tag, int id, _ns1__ReadenMolds *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_protocolv2__ns1__ReadenMolds, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_protocolv2__ns1__ReadenMolds ? type : NULL);
}

SOAP_FMAC3 _ns1__ReadenMolds ** SOAP_FMAC4 soap_in_PointerTo_ns1__ReadenMolds(struct soap *soap, const char *tag, _ns1__ReadenMolds **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ReadenMolds **)soap_malloc(soap, sizeof(_ns1__ReadenMolds *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ReadenMolds *)soap_instantiate__ns1__ReadenMolds(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ReadenMolds **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_protocolv2__ns1__ReadenMolds, sizeof(_ns1__ReadenMolds), 0, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ReadenMolds(struct soap *soap, _ns1__ReadenMolds *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ReadenMolds(soap, tag ? tag : "ns1:ReadenMolds", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ReadenMolds ** SOAP_FMAC4 soap_get_PointerTo_ns1__ReadenMolds(struct soap *soap, _ns1__ReadenMolds **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ReadenMolds(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__EjectedMolds(struct soap *soap, _ns1__EjectedMolds *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_protocolv2__ns1__EjectedMolds))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__EjectedMolds(struct soap *soap, const char *tag, int id, _ns1__EjectedMolds *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_protocolv2__ns1__EjectedMolds, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_protocolv2__ns1__EjectedMolds ? type : NULL);
}

SOAP_FMAC3 _ns1__EjectedMolds ** SOAP_FMAC4 soap_in_PointerTo_ns1__EjectedMolds(struct soap *soap, const char *tag, _ns1__EjectedMolds **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__EjectedMolds **)soap_malloc(soap, sizeof(_ns1__EjectedMolds *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__EjectedMolds *)soap_instantiate__ns1__EjectedMolds(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__EjectedMolds **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_protocolv2__ns1__EjectedMolds, sizeof(_ns1__EjectedMolds), 0, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__EjectedMolds(struct soap *soap, _ns1__EjectedMolds *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__EjectedMolds(soap, tag ? tag : "ns1:EjectedMolds", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__EjectedMolds ** SOAP_FMAC4 soap_get_PointerTo_ns1__EjectedMolds(struct soap *soap, _ns1__EjectedMolds **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__EjectedMolds(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__MountedMolds(struct soap *soap, _ns1__MountedMolds *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_protocolv2__ns1__MountedMolds))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__MountedMolds(struct soap *soap, const char *tag, int id, _ns1__MountedMolds *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_protocolv2__ns1__MountedMolds, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_protocolv2__ns1__MountedMolds ? type : NULL);
}

SOAP_FMAC3 _ns1__MountedMolds ** SOAP_FMAC4 soap_in_PointerTo_ns1__MountedMolds(struct soap *soap, const char *tag, _ns1__MountedMolds **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__MountedMolds **)soap_malloc(soap, sizeof(_ns1__MountedMolds *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__MountedMolds *)soap_instantiate__ns1__MountedMolds(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__MountedMolds **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_protocolv2__ns1__MountedMolds, sizeof(_ns1__MountedMolds), 0, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__MountedMolds(struct soap *soap, _ns1__MountedMolds *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__MountedMolds(soap, tag ? tag : "ns1:MountedMolds", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__MountedMolds ** SOAP_FMAC4 soap_get_PointerTo_ns1__MountedMolds(struct soap *soap, _ns1__MountedMolds **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__MountedMolds(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetUpdatedLastRequestDate(struct soap *soap, _ns1__GetUpdatedLastRequestDate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetUpdatedLastRequestDate(struct soap *soap, const char *tag, int id, _ns1__GetUpdatedLastRequestDate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDate, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDate ? type : NULL);
}

SOAP_FMAC3 _ns1__GetUpdatedLastRequestDate ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetUpdatedLastRequestDate(struct soap *soap, const char *tag, _ns1__GetUpdatedLastRequestDate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetUpdatedLastRequestDate **)soap_malloc(soap, sizeof(_ns1__GetUpdatedLastRequestDate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetUpdatedLastRequestDate *)soap_instantiate__ns1__GetUpdatedLastRequestDate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetUpdatedLastRequestDate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_protocolv2__ns1__GetUpdatedLastRequestDate, sizeof(_ns1__GetUpdatedLastRequestDate), 0, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetUpdatedLastRequestDate(struct soap *soap, _ns1__GetUpdatedLastRequestDate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetUpdatedLastRequestDate(soap, tag ? tag : "ns1:GetUpdatedLastRequestDate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetUpdatedLastRequestDate ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetUpdatedLastRequestDate(struct soap *soap, _ns1__GetUpdatedLastRequestDate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetUpdatedLastRequestDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PreserveCounts(struct soap *soap, _ns1__PreserveCounts *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_protocolv2__ns1__PreserveCounts))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PreserveCounts(struct soap *soap, const char *tag, int id, _ns1__PreserveCounts *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_protocolv2__ns1__PreserveCounts, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_protocolv2__ns1__PreserveCounts ? type : NULL);
}

SOAP_FMAC3 _ns1__PreserveCounts ** SOAP_FMAC4 soap_in_PointerTo_ns1__PreserveCounts(struct soap *soap, const char *tag, _ns1__PreserveCounts **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PreserveCounts **)soap_malloc(soap, sizeof(_ns1__PreserveCounts *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PreserveCounts *)soap_instantiate__ns1__PreserveCounts(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__PreserveCounts **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_protocolv2__ns1__PreserveCounts, sizeof(_ns1__PreserveCounts), 0, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PreserveCounts(struct soap *soap, _ns1__PreserveCounts *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__PreserveCounts(soap, tag ? tag : "ns1:PreserveCounts", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__PreserveCounts ** SOAP_FMAC4 soap_get_PointerTo_ns1__PreserveCounts(struct soap *soap, _ns1__PreserveCounts **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PreserveCounts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CountsByArticle(struct soap *soap, _ns1__CountsByArticle *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_protocolv2__ns1__CountsByArticle))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CountsByArticle(struct soap *soap, const char *tag, int id, _ns1__CountsByArticle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_protocolv2__ns1__CountsByArticle, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_protocolv2__ns1__CountsByArticle ? type : NULL);
}

SOAP_FMAC3 _ns1__CountsByArticle ** SOAP_FMAC4 soap_in_PointerTo_ns1__CountsByArticle(struct soap *soap, const char *tag, _ns1__CountsByArticle **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CountsByArticle **)soap_malloc(soap, sizeof(_ns1__CountsByArticle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CountsByArticle *)soap_instantiate__ns1__CountsByArticle(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CountsByArticle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_protocolv2__ns1__CountsByArticle, sizeof(_ns1__CountsByArticle), 0, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CountsByArticle(struct soap *soap, _ns1__CountsByArticle *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CountsByArticle(soap, tag ? tag : "ns1:CountsByArticle", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CountsByArticle ** SOAP_FMAC4 soap_get_PointerTo_ns1__CountsByArticle(struct soap *soap, _ns1__CountsByArticle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CountsByArticle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Counts(struct soap *soap, _ns1__Counts *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_protocolv2__ns1__Counts))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Counts(struct soap *soap, const char *tag, int id, _ns1__Counts *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_protocolv2__ns1__Counts, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_protocolv2__ns1__Counts ? type : NULL);
}

SOAP_FMAC3 _ns1__Counts ** SOAP_FMAC4 soap_in_PointerTo_ns1__Counts(struct soap *soap, const char *tag, _ns1__Counts **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Counts **)soap_malloc(soap, sizeof(_ns1__Counts *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Counts *)soap_instantiate__ns1__Counts(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__Counts **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_protocolv2__ns1__Counts, sizeof(_ns1__Counts), 0, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Counts(struct soap *soap, _ns1__Counts *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__Counts(soap, tag ? tag : "ns1:Counts", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Counts ** SOAP_FMAC4 soap_get_PointerTo_ns1__Counts(struct soap *soap, _ns1__Counts **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Counts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CCompteurMouleCapteur(struct soap *soap, ns1__CCompteurMouleCapteur **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_protocolv2_PointerTons1__CCompteurMouleCapteur))
		soap_serialize_PointerTons1__CCompteurMouleCapteur(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CCompteurMouleCapteur(struct soap *soap, const char *tag, int id, ns1__CCompteurMouleCapteur **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_protocolv2_PointerTons1__CCompteurMouleCapteur, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CCompteurMouleCapteur(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CCompteurMouleCapteur *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CCompteurMouleCapteur(struct soap *soap, const char *tag, ns1__CCompteurMouleCapteur ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CCompteurMouleCapteur ***)soap_malloc(soap, sizeof(ns1__CCompteurMouleCapteur **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CCompteurMouleCapteur(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CCompteurMouleCapteur ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_protocolv2_ns1__CCompteurMouleCapteur, sizeof(ns1__CCompteurMouleCapteur), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CCompteurMouleCapteur(struct soap *soap, ns1__CCompteurMouleCapteur **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__CCompteurMouleCapteur(soap, tag ? tag : "ns1:CCompteurMouleCapteur", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CCompteurMouleCapteur *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CCompteurMouleCapteur(struct soap *soap, ns1__CCompteurMouleCapteur ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CCompteurMouleCapteur(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CCompteurMouleCapteur(struct soap *soap, ns1__CCompteurMouleCapteur *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_protocolv2_ns1__CCompteurMouleCapteur))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CCompteurMouleCapteur(struct soap *soap, const char *tag, int id, ns1__CCompteurMouleCapteur *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_protocolv2_ns1__CCompteurMouleCapteur, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_protocolv2_ns1__CCompteurMouleCapteur ? type : NULL);
}

SOAP_FMAC3 ns1__CCompteurMouleCapteur ** SOAP_FMAC4 soap_in_PointerTons1__CCompteurMouleCapteur(struct soap *soap, const char *tag, ns1__CCompteurMouleCapteur **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CCompteurMouleCapteur **)soap_malloc(soap, sizeof(ns1__CCompteurMouleCapteur *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CCompteurMouleCapteur *)soap_instantiate_ns1__CCompteurMouleCapteur(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__CCompteurMouleCapteur **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_protocolv2_ns1__CCompteurMouleCapteur, sizeof(ns1__CCompteurMouleCapteur), 0, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CCompteurMouleCapteur(struct soap *soap, ns1__CCompteurMouleCapteur *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__CCompteurMouleCapteur(soap, tag ? tag : "ns1:CCompteurMouleCapteur", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CCompteurMouleCapteur ** SOAP_FMAC4 soap_get_PointerTons1__CCompteurMouleCapteur(struct soap *soap, ns1__CCompteurMouleCapteur **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CCompteurMouleCapteur(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CCounter(struct soap *soap, ns1__CCounter **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_protocolv2_PointerTons1__CCounter))
		soap_serialize_PointerTons1__CCounter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CCounter(struct soap *soap, const char *tag, int id, ns1__CCounter **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_protocolv2_PointerTons1__CCounter, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CCounter(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CCounter *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CCounter(struct soap *soap, const char *tag, ns1__CCounter ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CCounter ***)soap_malloc(soap, sizeof(ns1__CCounter **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CCounter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CCounter ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_protocolv2_ns1__CCounter, sizeof(ns1__CCounter), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CCounter(struct soap *soap, ns1__CCounter **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__CCounter(soap, tag ? tag : "ns1:CCounter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CCounter *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CCounter(struct soap *soap, ns1__CCounter ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CCounter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CCounter(struct soap *soap, ns1__CCounter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_protocolv2_ns1__CCounter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CCounter(struct soap *soap, const char *tag, int id, ns1__CCounter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_protocolv2_ns1__CCounter, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_protocolv2_ns1__CCounter ? type : NULL);
}

SOAP_FMAC3 ns1__CCounter ** SOAP_FMAC4 soap_in_PointerTons1__CCounter(struct soap *soap, const char *tag, ns1__CCounter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CCounter **)soap_malloc(soap, sizeof(ns1__CCounter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CCounter *)soap_instantiate_ns1__CCounter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__CCounter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_protocolv2_ns1__CCounter, sizeof(ns1__CCounter), 0, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CCounter(struct soap *soap, ns1__CCounter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__CCounter(soap, tag ? tag : "ns1:CCounter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CCounter ** SOAP_FMAC4 soap_get_PointerTons1__CCounter(struct soap *soap, ns1__CCounter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CCounter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfCCompteurArticle(struct soap *soap, ns1__ArrayOfCCompteurArticle *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_protocolv2_ns1__ArrayOfCCompteurArticle))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfCCompteurArticle(struct soap *soap, const char *tag, int id, ns1__ArrayOfCCompteurArticle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_protocolv2_ns1__ArrayOfCCompteurArticle, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_protocolv2_ns1__ArrayOfCCompteurArticle ? type : NULL);
}

SOAP_FMAC3 ns1__ArrayOfCCompteurArticle ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfCCompteurArticle(struct soap *soap, const char *tag, ns1__ArrayOfCCompteurArticle **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfCCompteurArticle **)soap_malloc(soap, sizeof(ns1__ArrayOfCCompteurArticle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfCCompteurArticle *)soap_instantiate_ns1__ArrayOfCCompteurArticle(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfCCompteurArticle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_protocolv2_ns1__ArrayOfCCompteurArticle, sizeof(ns1__ArrayOfCCompteurArticle), 0, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfCCompteurArticle(struct soap *soap, ns1__ArrayOfCCompteurArticle *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfCCompteurArticle(soap, tag ? tag : "ns1:ArrayOfCCompteurArticle", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfCCompteurArticle ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfCCompteurArticle(struct soap *soap, ns1__ArrayOfCCompteurArticle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfCCompteurArticle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CountsByArticleResult(struct soap *soap, ns1__CountsByArticleResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_protocolv2_ns1__CountsByArticleResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CountsByArticleResult(struct soap *soap, const char *tag, int id, ns1__CountsByArticleResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_protocolv2_ns1__CountsByArticleResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_protocolv2_ns1__CountsByArticleResult ? type : NULL);
}

SOAP_FMAC3 ns1__CountsByArticleResult ** SOAP_FMAC4 soap_in_PointerTons1__CountsByArticleResult(struct soap *soap, const char *tag, ns1__CountsByArticleResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CountsByArticleResult **)soap_malloc(soap, sizeof(ns1__CountsByArticleResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CountsByArticleResult *)soap_instantiate_ns1__CountsByArticleResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__CountsByArticleResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_protocolv2_ns1__CountsByArticleResult, sizeof(ns1__CountsByArticleResult), 0, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CountsByArticleResult(struct soap *soap, ns1__CountsByArticleResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__CountsByArticleResult(soap, tag ? tag : "ns1:CountsByArticleResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CountsByArticleResult ** SOAP_FMAC4 soap_get_PointerTons1__CountsByArticleResult(struct soap *soap, ns1__CountsByArticleResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CountsByArticleResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CCompteurArticle(struct soap *soap, ns1__CCompteurArticle **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_protocolv2_PointerTons1__CCompteurArticle))
		soap_serialize_PointerTons1__CCompteurArticle(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CCompteurArticle(struct soap *soap, const char *tag, int id, ns1__CCompteurArticle **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_protocolv2_PointerTons1__CCompteurArticle, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CCompteurArticle(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CCompteurArticle *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CCompteurArticle(struct soap *soap, const char *tag, ns1__CCompteurArticle ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CCompteurArticle ***)soap_malloc(soap, sizeof(ns1__CCompteurArticle **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CCompteurArticle(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CCompteurArticle ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_protocolv2_ns1__CCompteurArticle, sizeof(ns1__CCompteurArticle), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CCompteurArticle(struct soap *soap, ns1__CCompteurArticle **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__CCompteurArticle(soap, tag ? tag : "ns1:CCompteurArticle", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CCompteurArticle *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CCompteurArticle(struct soap *soap, ns1__CCompteurArticle ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CCompteurArticle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CCompteurArticle(struct soap *soap, ns1__CCompteurArticle *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_protocolv2_ns1__CCompteurArticle))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CCompteurArticle(struct soap *soap, const char *tag, int id, ns1__CCompteurArticle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_protocolv2_ns1__CCompteurArticle, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_protocolv2_ns1__CCompteurArticle ? type : NULL);
}

SOAP_FMAC3 ns1__CCompteurArticle ** SOAP_FMAC4 soap_in_PointerTons1__CCompteurArticle(struct soap *soap, const char *tag, ns1__CCompteurArticle **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CCompteurArticle **)soap_malloc(soap, sizeof(ns1__CCompteurArticle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CCompteurArticle *)soap_instantiate_ns1__CCompteurArticle(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__CCompteurArticle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_protocolv2_ns1__CCompteurArticle, sizeof(ns1__CCompteurArticle), 0, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CCompteurArticle(struct soap *soap, ns1__CCompteurArticle *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__CCompteurArticle(soap, tag ? tag : "ns1:CCompteurArticle", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CCompteurArticle ** SOAP_FMAC4 soap_get_PointerTons1__CCompteurArticle(struct soap *soap, ns1__CCompteurArticle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CCompteurArticle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_protocolv2_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_protocolv2_int, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_protocolv2_int, sizeof(int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToint(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CCompteurMachine(struct soap *soap, ns1__CCompteurMachine *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_protocolv2_ns1__CCompteurMachine))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CCompteurMachine(struct soap *soap, const char *tag, int id, ns1__CCompteurMachine *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_protocolv2_ns1__CCompteurMachine, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_protocolv2_ns1__CCompteurMachine ? type : NULL);
}

SOAP_FMAC3 ns1__CCompteurMachine ** SOAP_FMAC4 soap_in_PointerTons1__CCompteurMachine(struct soap *soap, const char *tag, ns1__CCompteurMachine **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CCompteurMachine **)soap_malloc(soap, sizeof(ns1__CCompteurMachine *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CCompteurMachine *)soap_instantiate_ns1__CCompteurMachine(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__CCompteurMachine **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_protocolv2_ns1__CCompteurMachine, sizeof(ns1__CCompteurMachine), 0, protocolv2_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CCompteurMachine(struct soap *soap, ns1__CCompteurMachine *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__CCompteurMachine(soap, tag ? tag : "ns1:CCompteurMachine", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CCompteurMachine ** SOAP_FMAC4 soap_get_PointerTons1__CCompteurMachine(struct soap *soap, ns1__CCompteurMachine **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CCompteurMachine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_protocolv2__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_protocolv2__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_protocolv2__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_protocolv2_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_protocolv2_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_protocolv2_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

} // namespace protocolv2


#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of protocolv2C.cpp */
